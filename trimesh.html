

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trimesh package &mdash; trimesh 3.2.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="trimesh.exchange package" href="trimesh.exchange.html" />
    <link rel="prev" title="Module Reference" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> trimesh
          

          
          </a>

          
            
            
              <div class="version">
                3.2.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Advanced Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Module Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">trimesh package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="trimesh.exchange.html">trimesh.exchange package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.interfaces.html">trimesh.interfaces package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.html">trimesh.path package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.ray.html">trimesh.ray package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.resources.html">trimesh.resources package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.scene.html">trimesh.scene package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.viewer.html">trimesh.viewer package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.visual.html">trimesh.visual package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.voxel.html">trimesh.voxel package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.base">trimesh.base module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#github-com-mikedh-trimesh">github.com/mikedh/trimesh</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.boolean">trimesh.boolean module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#boolean-py">boolean.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.bounds">trimesh.bounds module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.caching">trimesh.caching module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#caching-py">caching.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.collision">trimesh.collision module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.comparison">trimesh.comparison module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comparison-py">comparison.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.constants">trimesh.constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.convex">trimesh.convex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.creation">trimesh.creation module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creation-py">creation.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.curvature">trimesh.curvature module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#curvature-py">curvature.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.decomposition">trimesh.decomposition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.exceptions">trimesh.exceptions module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exceptions-py">exceptions.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.geometry">trimesh.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.graph">trimesh.graph module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-py">graph.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.grouping">trimesh.grouping module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grouping-py">grouping.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.inertia">trimesh.inertia module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inertia-py">inertia.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.integrate">trimesh.integrate module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#integrate-py">integrate.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.intersections">trimesh.intersections module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intersections-py">intersections.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.interval">trimesh.interval module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interval-py">interval.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.nsphere">trimesh.nsphere module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nsphere-py">nsphere.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.parent">trimesh.parent module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parent-py">parent.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.permutate">trimesh.permutate module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#permutate-py">permutate.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.points">trimesh.points module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#points-py">points.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.poses">trimesh.poses module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#poses-py">poses.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.primitives">trimesh.primitives module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#primitives-py">primitives.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.proximity">trimesh.proximity module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#proximity-py">proximity.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.registration">trimesh.registration module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#registration-py">registration.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.remesh">trimesh.remesh module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#remesh-py">remesh.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.rendering">trimesh.rendering module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rendering-py">rendering.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.repair">trimesh.repair module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#repair-py">repair.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.sample">trimesh.sample module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sample-py">sample.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.schemas">trimesh.schemas module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#schemas-py">schemas.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.smoothing">trimesh.smoothing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.transformations">trimesh.transformations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.triangles">trimesh.triangles module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#triangles-py">triangles.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.units">trimesh.units module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#units-py">units.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.util">trimesh.util module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#util-py">util.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.version">trimesh.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#https-github-com-mikedh-trimesh">https://github.com/mikedh/trimesh</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">trimesh</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">Module Reference</a> &raquo;</li>
        
      <li>trimesh package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/trimesh.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="trimesh-package">
<h1>trimesh package<a class="headerlink" href="#trimesh-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="trimesh.exchange.html">trimesh.exchange package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.assimp">trimesh.exchange.assimp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.binvox">trimesh.exchange.binvox module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.dae">trimesh.exchange.dae module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.export">trimesh.exchange.export module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.gltf">trimesh.exchange.gltf module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.exchange.html#gltf-py">gltf.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.load">trimesh.exchange.load module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.misc">trimesh.exchange.misc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.obj">trimesh.exchange.obj module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.openctm">trimesh.exchange.openctm module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.ply">trimesh.exchange.ply module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.stl">trimesh.exchange.stl module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.threemf">trimesh.exchange.threemf module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.urdf">trimesh.exchange.urdf module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.xml_based">trimesh.exchange.xml_based module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.interfaces.html">trimesh.interfaces package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.blender">trimesh.interfaces.blender module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.generic">trimesh.interfaces.generic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.gmsh">trimesh.interfaces.gmsh module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.scad">trimesh.interfaces.scad module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.vhacd">trimesh.interfaces.vhacd module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.path.html">trimesh.path package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.exchange.html">trimesh.path.exchange package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.dxf">trimesh.path.exchange.dxf module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.export">trimesh.path.exchange.export module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.load">trimesh.path.exchange.load module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.misc">trimesh.path.exchange.misc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.svg_io">trimesh.path.exchange.svg_io module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.arc">trimesh.path.arc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.creation">trimesh.path.creation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.curve">trimesh.path.curve module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.entities">trimesh.path.entities module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#entities-py">entities.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.intersections">trimesh.path.intersections module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.packing">trimesh.path.packing module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.path">trimesh.path.path module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.polygons">trimesh.path.polygons module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.raster">trimesh.path.raster module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#raster-py">raster.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.repair">trimesh.path.repair module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#repair-py">repair.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.segments">trimesh.path.segments module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#segments-py">segments.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.simplify">trimesh.path.simplify module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.traversal">trimesh.path.traversal module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.util">trimesh.path.util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.ray.html">trimesh.ray package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_pyembree">trimesh.ray.ray_pyembree module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_triangle">trimesh.ray.ray_triangle module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_util">trimesh.ray.ray_util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.resources.html">trimesh.resources package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.resources.html#module-trimesh.resources">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.scene.html">trimesh.scene package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.cameras">trimesh.scene.cameras module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.lighting">trimesh.scene.lighting module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.scene.html#lighting-py">lighting.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.scene">trimesh.scene.scene module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.transforms">trimesh.scene.transforms module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.viewer.html">trimesh.viewer package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#module-trimesh.viewer.notebook">trimesh.viewer.notebook module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.viewer.html#notebook-py">notebook.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#module-trimesh.viewer.trackball">trimesh.viewer.trackball module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#trimesh-viewer-widget-module">trimesh.viewer.widget module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#module-trimesh.viewer.windowed">trimesh.viewer.windowed module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.viewer.html#windowed-py">windowed.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#module-trimesh.viewer">Module contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.viewer.html#viewer">viewer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.visual.html">trimesh.visual package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.color">trimesh.visual.color module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#color-py">color.py</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#rules">Rules</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.material">trimesh.visual.material module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#material-py">material.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.objects">trimesh.visual.objects module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#objects-py">objects.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.resolvers">trimesh.visual.resolvers module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#resolvers-py">resolvers.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.texture">trimesh.visual.texture module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual">Module contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#visual">visual</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.voxel.html">trimesh.voxel package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel.base">trimesh.voxel.base module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.voxel.html#voxel-py">voxel.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel.creation">trimesh.voxel.creation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel.encoding">trimesh.voxel.encoding module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel.morphology">trimesh.voxel.morphology module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel.ops">trimesh.voxel.ops module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel.runlength">trimesh.voxel.runlength module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel.transforms">trimesh.voxel.transforms module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.voxel.html#module-trimesh.voxel">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-trimesh.base">
<span id="trimesh-base-module"></span><h2>trimesh.base module<a class="headerlink" href="#module-trimesh.base" title="Permalink to this headline">¶</a></h2>
<div class="section" id="github-com-mikedh-trimesh">
<h3>github.com/mikedh/trimesh<a class="headerlink" href="#github-com-mikedh-trimesh" title="Permalink to this headline">¶</a></h3>
<p>Library for importing, exporting and doing simple operations on triangular meshes.</p>
<dl class="class">
<dt id="trimesh.base.Trimesh">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.base.</code><code class="sig-name descname">Trimesh</code><span class="sig-paren">(</span><em class="sig-param">vertices=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">face_normals=None</em>, <em class="sig-param">vertex_normals=None</em>, <em class="sig-param">face_colors=None</em>, <em class="sig-param">vertex_colors=None</em>, <em class="sig-param">face_attributes=None</em>, <em class="sig-param">vertex_attributes=None</em>, <em class="sig-param">metadata=None</em>, <em class="sig-param">process=True</em>, <em class="sig-param">validate=False</em>, <em class="sig-param">use_embree=True</em>, <em class="sig-param">initial_cache=None</em>, <em class="sig-param">visual=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<dl class="method">
<dt id="trimesh.base.Trimesh.apply_obb">
<code class="sig-name descname">apply_obb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_obb" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the oriented bounding box transform to the current mesh.</p>
<p>This will result in a mesh with an AABB centered at the
origin and the same dimensions as the OBB.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>matrix</strong> – Transformation matrix that was applied
to mesh to move it into OBB frame</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(4, 4) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.apply_transform">
<code class="sig-name descname">apply_transform</code><span class="sig-paren">(</span><em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mesh by a homogeneous transformation matrix.</p>
<p>Does the bookkeeping to avoid recomputing things so this function
should be used rather than directly modifying self.vertices
if possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Homogeneous transformation matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.area">
<em class="property">property </em><code class="sig-name descname">area</code><a class="headerlink" href="#trimesh.base.Trimesh.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Summed area of all triangles in the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area</strong> – Surface area of mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.area_faces">
<em class="property">property </em><code class="sig-name descname">area_faces</code><a class="headerlink" href="#trimesh.base.Trimesh.area_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The area of each face in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area_faces</strong> – Area of each face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.body_count">
<em class="property">property </em><code class="sig-name descname">body_count</code><a class="headerlink" href="#trimesh.base.Trimesh.body_count" title="Permalink to this definition">¶</a></dt>
<dd><p>How many connected groups of vertices exist in this mesh.</p>
<p>Note that this number may differ from result in mesh.split,
which is calculated from FACE rather than vertex adjacency.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>count</strong> – Number of connected vertex groups</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.bounds">
<em class="property">property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#trimesh.base.Trimesh.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the faces of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bounds</strong> – Bounding box with [min, max] coordinates</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.center_mass">
<em class="property">property </em><code class="sig-name descname">center_mass</code><a class="headerlink" href="#trimesh.base.Trimesh.center_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the center of mass/volume.</p>
<p>If the current mesh is not watertight, this is meaningless garbage
unless it was explicitly set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>center_mass</strong> – Volumetric center of mass of the mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.centroid">
<em class="property">property </em><code class="sig-name descname">centroid</code><a class="headerlink" href="#trimesh.base.Trimesh.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the average of the triangle centroids
weighted by the area of each triangle.</p>
<p>This will be valid even for non- watertight meshes,
unlike self.center_mass</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>centroid</strong> – The average vertex weighted by face area</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.compute_stable_poses">
<code class="sig-name descname">compute_stable_poses</code><span class="sig-paren">(</span><em class="sig-param">center_mass=None</em>, <em class="sig-param">sigma=0.0</em>, <em class="sig-param">n_samples=1</em>, <em class="sig-param">threshold=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.compute_stable_poses" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p>
<p>This method samples the location of the center of mass from a multivariate
gaussian (mean at com, cov equal to identity times sigma) over n_samples.
For each sample, it computes the stable resting poses of the mesh on a
a planar workspace and evaluates the probabilities of landing in
each pose if the object is dropped onto the table randomly.</p>
<p>This method returns the 4x4 homogeneous transform matrices that place
the shape against the planar surface with the z-axis pointing upwards
and a list of the probabilities for each pose.
The transforms and probabilties that are returned are sorted, with the
most probable pose first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center_mass</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – The object center of mass (if None, this method
assumes uniform density and watertightness and
computes a center of mass explicitly)</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – The covariance for the multivariate gaussian used
to sample center of mass locations</p></li>
<li><p><strong>n_samples</strong> (<em>int</em>) – The number of samples of the center of mass location</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The probability value at which to threshold
returned stable poses</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>transforms</strong> (<em>(n, 4, 4) float</em>) – The homogeneous matrices that transform the
object to rest in a stable pose, with the
new z-axis pointing upwards from the table
and the object just touching the table.</p></li>
<li><p><strong>probs</strong> (<em>(n,) float</em>) – A probability ranging from 0.0 to 1.0 for each pose</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.contains">
<code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, determine whether or not they are inside the mesh.
This raises an error if called on a non- watertight mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points in cartesian space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>contains</strong> – Whether or not each point is inside the mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, ) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.convert_units">
<code class="sig-name descname">convert_units</code><span class="sig-paren">(</span><em class="sig-param">desired</em>, <em class="sig-param">guess=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.convert_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the units of the mesh into a specified unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>desired</strong> (<em>string</em>) – Units to convert to (eg ‘inches’)</p></li>
<li><p><strong>guess</strong> (<em>boolean</em>) – If self.units are not defined should we
guess the current units of the document and then convert?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.convex_decomposition">
<code class="sig-name descname">convex_decomposition</code><span class="sig-paren">(</span><em class="sig-param">maxhulls=20</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.convex_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate convex decomposition of a mesh.</p>
<p>testVHACD Parameters which can be passed as kwargs:</p>
<p>resolution                                  100000
max. concavity                              0.001
plane down-sampling                         4
convex-hull down-sampling                   4
alpha                                       0.05
beta                                        0.05
maxhulls                                    10
pca                                         0
mode                                        0
max. vertices per convex-hull               64
min. volume to add vertices to convex-hulls 0.0001
convex-hull approximation                   1
OpenCL acceleration                         1
OpenCL platform ID                          0
OpenCL device ID                            0
output                                      output.wrl
log                                         log.txt</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxhulls</strong> (<em>int</em>) – Maximum number of convex hulls to return</p></li>
<li><p><strong>**kwargs</strong> (<em>testVHACD keyword arguments</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>meshes</strong> – List of convex meshes that approximate the original</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of trimesh.Trimesh</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.convex_hull">
<em class="property">property </em><code class="sig-name descname">convex_hull</code><a class="headerlink" href="#trimesh.base.Trimesh.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Trimesh object representing the convex hull of
the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>convex</strong> – Mesh of convex hull of current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely get a copy of the current mesh.</p>
<p>Copied objects will have emptied caches to avoid memory
issues and so may be slow on initial operations until
caches are regenerated.</p>
<p>Current object will <em>not</em> have its cache cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>copied</strong> – Copy of current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.crc">
<code class="sig-name descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A zlib.adler32 checksum for the current mesh data.</p>
<p>This is about 5x faster than an MD5, and the checksum is
checked every time something is requested from the cache so
it gets called a lot.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>crc</strong> – Checksum of current mesh data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.density">
<em class="property">property </em><code class="sig-name descname">density</code><a class="headerlink" href="#trimesh.base.Trimesh.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The density of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>density</strong> – The density of the mesh.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.difference">
<code class="sig-name descname">difference</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean difference between this mesh and n other meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, or </em><em>list of trimesh.Trimesh objects</em>) – Meshes to difference</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>difference</strong> – Difference between self and other Trimesh objects</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.edges">
<em class="property">property </em><code class="sig-name descname">edges</code><a class="headerlink" href="#trimesh.base.Trimesh.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges of the mesh (derived from faces).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges</strong> – List of vertex indices making up edges</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.edges_face">
<em class="property">property </em><code class="sig-name descname">edges_face</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_face" title="Permalink to this definition">¶</a></dt>
<dd><p>Which face does each edge belong to.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_face</strong> – Index of self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.edges_sorted">
<em class="property">property </em><code class="sig-name descname">edges_sorted</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges sorted along axis 1</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_sorted</strong> – Same as self.edges but sorted along axis 1</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.edges_sparse">
<em class="property">property </em><code class="sig-name descname">edges_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges in sparse bool COO graph format where connected
vertices are True.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sparse</strong> – Sparse graph in COO format</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), len(self.vertices)) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.edges_unique">
<em class="property">property </em><code class="sig-name descname">edges_unique</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique edges of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_unique</strong> – Vertex indices for unique edges</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.edges_unique_inverse">
<em class="property">property </em><code class="sig-name descname">edges_unique_inverse</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse required to reproduce
self.edges_sorted from self.edges_unique.</p>
<p>Useful for referencing edge properties:
mesh.edges_unique[mesh.edges_unique_inverse] == m.edges_sorted</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>inverse</strong> – Indexes of self.edges_unique</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.edges),) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.edges_unique_length">
<em class="property">property </em><code class="sig-name descname">edges_unique_length</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique_length" title="Permalink to this definition">¶</a></dt>
<dd><p>How long is each unique edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>length</strong> – Length of each unique edge</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.edges_unique), ) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.euler_number">
<em class="property">property </em><code class="sig-name descname">euler_number</code><a class="headerlink" href="#trimesh.base.Trimesh.euler_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euler characteristic (a topological invariant) for the mesh
In order to guarantee correctness, this should be called after
remove_unreferenced_vertices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>euler_number</strong> – Topological invariant</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.eval_cached">
<code class="sig-name descname">eval_cached</code><span class="sig-paren">(</span><em class="sig-param">statement</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.eval_cached" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a statement and cache the result before returning.</p>
<p>Statements are evaluated inside the Trimesh object, and</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>statement</strong> (<em>str</em>) – Statement of valid python code</p></li>
<li><p><strong>*args</strong> (<em>list</em>) – Available inside statement as args[0], etc</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>result of running eval on statement with args</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>r = mesh.eval_cached(‘np.dot(self.vertices, args[0])’, [0,0,1])</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.export">
<code class="sig-name descname">export</code><span class="sig-paren">(</span><em class="sig-param">file_obj=None</em>, <em class="sig-param">file_type=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the current mesh to a file object.
If file_obj is a filename, file will be written there.</p>
<p>Supported formats are stl, off, ply, collada, json, dict, glb,
dict64, msgpack.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> (<em>open writeable file object</em>) – str, file name where to save the mesh
None, if you would like this function to return the export blob</p></li>
<li><p><strong>file_type</strong> (<em>str</em>) – Which file type to export as.
If file name is passed this is not required</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.extents">
<em class="property">property </em><code class="sig-name descname">extents</code><a class="headerlink" href="#trimesh.base.Trimesh.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The length, width, and height of the bounding box of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>extents</strong> – Array containing axis aligned [length, width, height]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency">
<em class="property">property </em><code class="sig-name descname">face_adjacency</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>adjacency</strong> – Pairs of faces which share an edge</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,2) int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: mesh = trimesh.load(‘models/featuretype.STL’)</p>
<p>In [2]: mesh.face_adjacency
Out[2]:
array([[   0,    1],</p>
<blockquote>
<div><p>[   2,    3],
[   0,    3],
…,
[1112,  949],
[3467, 3475],
[1113, 3475]])</p>
</div></blockquote>
<p>In [3]: mesh.faces[mesh.face_adjacency[0]]
Out[3]:
TrackedArray([[   1,    0,  408],</p>
<blockquote>
<div><p>[1239,    0,    1]], dtype=int64)</p>
</div></blockquote>
<p>In [4]: import networkx as nx</p>
<p>In [5]: graph = nx.from_edgelist(mesh.face_adjacency)</p>
<p>In [6]: groups = nx.connected_components(graph)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_angles">
<em class="property">property </em><code class="sig-name descname">face_adjacency_angles</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle between adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>adjacency_angle</strong> – Angle between adjacent faces
Each value corresponds with self.face_adjacency</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_convex">
<em class="property">property </em><code class="sig-name descname">face_adjacency_convex</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return faces which are adjacent and locally convex.</p>
<p>What this means is that given faces A and B, the one vertex
in B that is not shared with A, projected onto the plane of A
has a projection that is zero or negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>are_convex</strong> – Face pairs that are locally convex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_edges">
<em class="property">property </em><code class="sig-name descname">face_adjacency_edges</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the edges that are shared by the adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges</strong> – Vertex indices which correspond to face_adjacency</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_projections">
<em class="property">property </em><code class="sig-name descname">face_adjacency_projections</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection of the non- shared vertex of a triangle onto
its adjacent face</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>projections</strong> – Dot product of vertex
onto plane of adjacent triangle.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_radius">
<em class="property">property </em><code class="sig-name descname">face_adjacency_radius</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>radii</strong> – Approximate radius formed by triangle pair</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_span">
<em class="property">property </em><code class="sig-name descname">face_adjacency_span</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_span" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate perpendicular projection of the non- shared
vertices in a pair of adjacent faces onto the shared edge of
the two faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>span</strong> – Approximate span between the non- shared vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_tree">
<em class="property">property </em><code class="sig-name descname">face_adjacency_tree</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree of face adjacencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tree</strong> – Where each edge in self.face_adjacency has a
rectangular cell</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rtree.index</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_adjacency_unshared">
<em class="property">property </em><code class="sig-name descname">face_adjacency_unshared</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_unshared" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex index of the two vertices not in the shared
edge between two adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vid_unshared</strong> – Indexes of mesh.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(mesh.face_adjacency), 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_angles">
<em class="property">property </em><code class="sig-name descname">face_angles</code><a class="headerlink" href="#trimesh.base.Trimesh.face_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angle at each vertex of a face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>angles</strong> – Angle at each vertex of a face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_angles_sparse">
<em class="property">property </em><code class="sig-name descname">face_angles_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.face_angles_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the face angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sparse</strong> – dtype: float
shape: (len(self.vertices), len(self.faces))</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.sparse.coo_matrix with:</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.face_normals">
<em class="property">property </em><code class="sig-name descname">face_normals</code><a class="headerlink" href="#trimesh.base.Trimesh.face_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unit normal vector for each face.</p>
<p>If a face is degenerate and a normal can’t be generated
a zero magnitude unit vector will be returned for that face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>normals</strong> – Normal vectors of each face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.faces), 3) np.float64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.faces">
<em class="property">property </em><code class="sig-name descname">faces</code><a class="headerlink" href="#trimesh.base.Trimesh.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The faces of the mesh.</p>
<p>This is regarded as core information which cannot be regenerated from
cache, and as such is stored in self._data which tracks the array for
changes and clears cached values of the mesh if this is altered.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>faces</strong> – Representing triangles which reference self.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,3) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.faces_sparse">
<em class="property">property </em><code class="sig-name descname">faces_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.faces_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sparse</strong> – Has properties:
dtype : bool
shape : (len(self.vertices), len(self.faces))</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.sparse.coo_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.faces_unique_edges">
<em class="property">property </em><code class="sig-name descname">faces_unique_edges</code><a class="headerlink" href="#trimesh.base.Trimesh.faces_unique_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>For each face return which indexes in mesh.unique_edges constructs
that face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>faces_unique_edges</strong> – Indexes of self.edges_unique that
construct self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.faces), 3) int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [0]: mesh.faces[0:2]
Out[0]:
TrackedArray([[    1,  6946, 24224],</p>
<blockquote>
<div><p>[ 6946,  1727, 24225]])</p>
</div></blockquote>
<p>In [1]: mesh.edges_unique[mesh.faces_unique_edges[0:2]]
Out[1]:
array([[[    1,  6946],</p>
<blockquote>
<div><blockquote>
<div><p>[ 6946, 24224],
[    1, 24224]],</p>
</div></blockquote>
<dl class="simple">
<dt>[[ 1727,  6946],</dt><dd><p>[ 1727, 24225],
[ 6946, 24225]]])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.facets">
<em class="property">property </em><code class="sig-name descname">facets</code><a class="headerlink" href="#trimesh.base.Trimesh.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of face indices for coplanar adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>facets</strong> – Groups of indexes of self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, ) sequence of (m,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.facets_area">
<em class="property">property </em><code class="sig-name descname">facets_area</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array containing the area of each facet.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area</strong> – Total area of each facet (group of faces)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.facets),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.facets_boundary">
<em class="property">property </em><code class="sig-name descname">facets_boundary</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edges which represent the boundary of each facet</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_boundary</strong> – Indices of self.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>sequence of (n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.facets_normal">
<em class="property">property </em><code class="sig-name descname">facets_normal</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normal of each facet</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>normals</strong> – A unit normal vector for each facet</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.facets), 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.facets_on_hull">
<em class="property">property </em><code class="sig-name descname">facets_on_hull</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_on_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Find which facets of the mesh are on the convex hull.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>on_hull</strong> – is A facet on the meshes convex hull or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(mesh.facets),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.facets_origin">
<em class="property">property </em><code class="sig-name descname">facets_origin</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a point on the facet plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>origins</strong> – A point on each facet plane</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.facets), 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.fill_holes">
<code class="sig-name descname">fill_holes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill single triangle and single quad holes in the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>watertight</strong> – Is the mesh watertight after the function completes</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.fix_normals">
<code class="sig-name descname">fix_normals</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and fix problems with self.face_normals and self.faces
winding direction.</p>
<p>For face normals ensure that vectors are consistently pointed
outwards, and that self.faces is wound in the correct direction
for all connected components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>multibody</strong> (<em>None</em><em> or </em><em>bool</em>) – Fix normals across multiple bodies
if None automatically pick from body_count</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.identifier">
<em class="property">property </em><code class="sig-name descname">identifier</code><a class="headerlink" href="#trimesh.base.Trimesh.identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a float vector which is unique to the mesh
and is robust to rotation and translation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>identifier</strong> – Identifying properties of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(6,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.identifier_md5">
<em class="property">property </em><code class="sig-name descname">identifier_md5</code><a class="headerlink" href="#trimesh.base.Trimesh.identifier_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the rotation invariant identifier vector</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>hashed</strong> – MD5 hash of the identifier vector</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean intersection between this mesh and n other meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, or </em><em>list of trimesh.Trimesh objects</em>) – Meshes to calculate intersections with</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intersection</strong> – Mesh of the volume contained by all passed meshes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the mesh in- place by reversing the winding of every
face and negating normals without dumping the cache.</p>
<p>self.faces :          columns reversed
self.face_normals :   negated if defined
self.vertex_normals : negated if defined</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.is_convex">
<em class="property">property </em><code class="sig-name descname">is_convex</code><a class="headerlink" href="#trimesh.base.Trimesh.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is convex or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>is_convex</strong> – Is mesh convex or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.is_empty">
<em class="property">property </em><code class="sig-name descname">is_empty</code><a class="headerlink" href="#trimesh.base.Trimesh.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the current mesh have data defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>empty</strong> – If True, no data is set on the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.is_volume">
<em class="property">property </em><code class="sig-name descname">is_volume</code><a class="headerlink" href="#trimesh.base.Trimesh.is_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh has all the properties required to represent
a valid volume, rather than just a surface.</p>
<p>These properties include being watertight, having consistent
winding and outward facing normals.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>valid</strong> – Does the mesh represent a volume</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.is_watertight">
<em class="property">property </em><code class="sig-name descname">is_watertight</code><a class="headerlink" href="#trimesh.base.Trimesh.is_watertight" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is watertight by making sure every edge is
included in two faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>is_watertight</strong> – Is mesh watertight or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.is_winding_consistent">
<em class="property">property </em><code class="sig-name descname">is_winding_consistent</code><a class="headerlink" href="#trimesh.base.Trimesh.is_winding_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the mesh have consistent winding or not.
A mesh with consistent winding has each shared edge
going in an opposite direction from the other in the pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>consistent</strong> – Is winding is consistent or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.kdtree">
<em class="property">property </em><code class="sig-name descname">kdtree</code><a class="headerlink" href="#trimesh.base.Trimesh.kdtree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.
Not cached as this lead to observed memory issues and segfaults.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tree</strong> – Contains mesh.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.spatial.cKDTree</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.mass">
<em class="property">property </em><code class="sig-name descname">mass</code><a class="headerlink" href="#trimesh.base.Trimesh.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass of the current mesh, based on specified density and
volume. If the current mesh isn’t watertight this is garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>mass</strong> – Mass of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.mass_properties">
<em class="property">property </em><code class="sig-name descname">mass_properties</code><a class="headerlink" href="#trimesh.base.Trimesh.mass_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mass properties of the current mesh.</p>
<p>Assumes uniform density, and result is probably garbage if mesh
isn’t watertight.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><strong>properties</strong> – With keys:
‘volume’      : in global units^3
‘mass’        : From specified density
‘density’     : Included again for convenience (same as kwarg density)
‘inertia’     : Taken at the center of mass and aligned with global</p>
<blockquote>
<div><p>coordinate system</p>
</div></blockquote>
<p>’center_mass’ : Center of mass location, in global coordinate system</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.md5">
<code class="sig-name descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the core geometry information for the mesh,
faces and vertices.</p>
<p>Generated from TrackedArray which subclasses np.ndarray to
monitor array for changes and returns a correct lazily
evaluated md5 so it only has to recalculate the hash
occasionally, rather than on every call.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>md5</strong> – MD5 of everything in the DataStore</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.merge_vertices">
<code class="sig-name descname">merge_vertices</code><span class="sig-paren">(</span><em class="sig-param">digits=None</em>, <em class="sig-param">textured=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has vertices that are closer than
trimesh.constants.tol.merge reindex faces to reference
the same index for both vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>digits</strong> (<em>int</em>) – If specified overrides tol.merge</p></li>
<li><p><strong>textured</strong> (<em>bool</em>) – If True avoids merging vertices with different UV
coordinates. No effect on untextured meshes.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.moment_inertia">
<em class="property">property </em><code class="sig-name descname">moment_inertia</code><a class="headerlink" href="#trimesh.base.Trimesh.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the moment of inertia matrix of the current mesh.
If mesh isn’t watertight this is garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>inertia</strong> – Moment of inertia of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.outline">
<code class="sig-name descname">outline</code><span class="sig-paren">(</span><em class="sig-param">face_ids=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of face indexes find the outline of those
faces and return it as a Path3D.</p>
<p>The outline is defined here as every edge which is only
included by a single triangle.</p>
<p>Note that this implies a non-watertight mesh as the
outline of a watertight mesh is an empty path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>face_ids</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>int</em>) – Indices to compute the outline of.
If None, outline of full mesh will be computed.</p></li>
<li><p><strong>**kwargs</strong> (<em>passed to Path3D constructor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>path</strong> – Curve in 3D of the outline</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path3D" title="trimesh.path.path.Path3D">Path3D</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.principal_inertia_components">
<em class="property">property </em><code class="sig-name descname">principal_inertia_components</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal components of inertia</p>
<p>Ordering corresponds to mesh.principal_inertia_vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>components</strong> – Principal components of inertia</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.principal_inertia_transform">
<em class="property">property </em><code class="sig-name descname">principal_inertia_transform</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A transform which moves the current mesh so the principal
inertia vectors are on the X,Y, and Z axis, and the centroid is
at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>transform</strong> – Homogeneous transformation matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(4, 4) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.principal_inertia_vectors">
<em class="property">property </em><code class="sig-name descname">principal_inertia_vectors</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal axis of inertia.</p>
<p>Ordering corresponds to mesh.principal_inertia_components</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vectors</strong> – Three vectors pointing along the
principal axis of inertia directions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.process">
<code class="sig-name descname">process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the bare minimum processing to make a mesh useful.</p>
<dl class="simple">
<dt>Does this by:</dt><dd><ol class="arabic simple">
<li><p>removing NaN and Inf values</p></li>
<li><p>merging duplicate vertices</p></li>
</ol>
</dd>
<dt>If self._validate:</dt><dd><ol class="arabic simple" start="3">
<li><p>Remove triangles which have one edge of their rectangular 2D
oriented bounding box shorter than tol.merge</p></li>
<li><p>remove duplicated triangles</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>self</strong> – Current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.referenced_vertices">
<em class="property">property </em><code class="sig-name descname">referenced_vertices</code><a class="headerlink" href="#trimesh.base.Trimesh.referenced_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Which vertices in the current mesh are referenced by a face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>referenced</strong> – Which vertices are referenced by a face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.register">
<code class="sig-name descname">register</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a mesh with another mesh or a PointCloud using
the principal axes of inertia as a starting point which
is refined by iterative closest point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>trimesh.Trimesh object</em>) – Mesh to align with other</p></li>
<li><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em> or </em><em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Mesh or points in space</p></li>
<li><p><strong>samples</strong> (<em>int</em>) – Number of samples from mesh surface to align</p></li>
<li><p><strong>icp_first</strong> (<em>int</em>) – How many ICP iterations for the 9 possible
combinations of</p></li>
<li><p><strong>icp_final</strong> (<em>int</em>) – How many ICP itertations for the closest
candidate from the wider search</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mesh_to_other</strong> (<em>(4, 4) float</em>) – Transform to align mesh to the other object</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Average square distance per point</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_degenerate_faces">
<code class="sig-name descname">remove_degenerate_faces</code><span class="sig-paren">(</span><em class="sig-param">height=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_degenerate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove degenerate faces (faces without 3 unique vertex indices)
from the current mesh.</p>
<p>If a height is specified, it will remove any face with a 2D oriented
bounding box with one edge shorter than that height.</p>
<p>If not specified, it will remove any face with a zero normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>height</strong> (<em>float</em>) – If specified removes faces with an oriented bounding
box shorter than this on one side.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nondegenerate</strong> – Mask used to remove faces</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(len(self.faces),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_duplicate_faces">
<code class="sig-name descname">remove_duplicate_faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_duplicate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>On the current mesh remove any faces which are duplicates.</p>
<p>self.faces : removes duplicates</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_infinite_values">
<code class="sig-name descname">remove_infinite_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_infinite_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that every vertex and face consists of finite numbers.</p>
<p>This will remove vertices or faces containing np.nan and np.inf</p>
<p>self.faces : masked to remove np.inf/np.nan
self.vertices : masked to remove np.inf/np.nan</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_unreferenced_vertices">
<code class="sig-name descname">remove_unreferenced_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_unreferenced_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all vertices in the current mesh which are not
referenced by a face.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.rezero">
<code class="sig-name descname">rezero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.rezero" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the mesh so that all vertex vertices are positive.</p>
<p>self.vertices : Translated to first octant (all values &gt; 0)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">count</em>, <em class="sig-param">return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples distributed normally across the
surface of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>count</strong> (<em>int</em>) – Number of points to sample</p></li>
<li><p><strong>return_index</strong> (<em>bool</em>) – If True will also return the index of which face each
sample was taken from.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>samples</strong> (<em>(count, 3) float</em>) – Points on surface of mesh</p></li>
<li><p><strong>face_index</strong> (<em>(count, ) int</em>) – Index of self.faces</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#trimesh.base.Trimesh.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>A metric for the overall scale of the mesh, the length of the
diagonal of the axis aligned bounding box of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scale</strong> – The length of the meshes AABB diagonal</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.scene">
<code class="sig-name descname">scene</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Scene object containing the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scene</strong> – Contains just the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="trimesh.scene.html#trimesh.scene.scene.Scene" title="trimesh.scene.scene.Scene">trimesh.scene.scene.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.section">
<code class="sig-name descname">section</code><span class="sig-paren">(</span><em class="sig-param">plane_normal</em>, <em class="sig-param">plane_origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3D cross section of the current mesh and a plane
defined by origin and normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_normal</strong> – Normal vector of section plane</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on the cross section plane</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intersections</strong> – Curve of intersection</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path3D" title="trimesh.path.path.Path3D">Path3D</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.section_multiplane">
<code class="sig-name descname">section_multiplane</code><span class="sig-paren">(</span><em class="sig-param">plane_origin</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">heights</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.section_multiplane" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multiple parallel cross sections of the current
mesh in 2D.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_normal</strong> – Normal vector of section plane</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on the cross section plane</p></li>
<li><p><strong>heights</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Each section is offset by height along
the plane normal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>paths</strong> – 2D cross sections at specified heights.
path.metadata[‘to_3D’] contains transform
to return 2D section back into 3D space.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) <a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path2D" title="trimesh.path.path.Path2D">Path2D</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the mesh in an opengl window. Requires pyglet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>smooth</strong> (<em>bool</em>) – Run smooth shading on mesh or not,
large meshes will be slow</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>scene</strong> – Scene with current mesh in it</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>trimesh.scene.Scene</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.slice_plane">
<code class="sig-name descname">slice_plane</code><span class="sig-paren">(</span><em class="sig-param">plane_origin</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.slice_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns another mesh that is the current mesh
sliced by the plane defined by origin and normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_normal</strong> – Normal vector of slicing plane</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on the slicing plane</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>new_mesh</strong> – Subset of current mesh sliced by plane</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of the current mesh which will render
nicely, without changing source mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>angle</strong> (<em>float</em>) – Angle in radians, face pairs with angles smaller than
this value will appear smoothed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>smoothed</strong> – Non watertight version of current mesh
which will render nicely with smooth shading</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Trimesh objects, based on face connectivity.
Splits into individual components, sometimes referred to as ‘bodies’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>only_watertight</strong> (<em>bool</em>) – Only return watertight meshes and discard remainder</p></li>
<li><p><strong>adjacency</strong> (<em>None</em><em> or </em><em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>int</em>) – Override face adjacency with custom values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>meshes</strong> – Separate bodies from original mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) <a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.subdivide">
<code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">face_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh, with each subdivided face replaced with four
smaller faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>face_index</strong> (<em>(</em><em>m</em><em>,</em><em>) </em><em>int</em><em> or </em><em>None</em>) – If None all faces of mesh will be subdivided
If (m,) int array of indices: only specified faces will be
subdivided. Note that in this case the mesh will generally
no longer be manifold, as the additional vertex on the midpoint
will not be used by the adjacent faces to the faces specified,
and an additional postprocessing step will be required to
make resulting mesh watertight</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.submesh">
<code class="sig-name descname">submesh</code><span class="sig-paren">(</span><em class="sig-param">faces_sequence</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.submesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>faces_sequence</strong> (<em>sequence</em><em> (</em><em>m</em><em>,</em><em>) </em><em>int</em>) – Face indices of mesh</p></li>
<li><p><strong>only_watertight</strong> (<em>bool</em>) – Only return submeshes which are watertight</p></li>
<li><p><strong>append</strong> (<em>bool</em>) – Return a single mesh which has the faces appended.
if this flag is set, only_watertight is ignored</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>if append</strong> (<em>trimesh.Trimesh object</em>)</p></li>
<li><p><strong>else</strong> (<em>list of trimesh.Trimesh objects</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.symmetry">
<em class="property">property </em><code class="sig-name descname">symmetry</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a mesh has rotational symmetry.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>symmetry</strong> – ‘radial’     Symmetric around an axis
‘spherical’  Symmetric around a point</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None         No rotational symmetry</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.symmetry_axis">
<em class="property">property </em><code class="sig-name descname">symmetry_axis</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>axis</strong> – Axis around which a 2D profile
was revolved to generate this mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.symmetry_section">
<em class="property">property </em><code class="sig-name descname">symmetry_section</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry_section" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the two
vectors which make up a section coordinate frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>section</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float, vectors to take a section along</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.to_dict">
<code class="sig-name descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the current mesh, with keys
that can be used as the kwargs for the Trimesh constructor, eg:</p>
<p>a = Trimesh(<a href="#id1"><span class="problematic" id="id2">**</span></a>other_mesh.to_dict())</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>result</strong> – With keys that match trimesh constructor</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.triangles">
<em class="property">property </em><code class="sig-name descname">triangles</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Actual triangles of the mesh (points, not indexes)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>triangles</strong> – Points of triangle vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.triangles_center">
<em class="property">property </em><code class="sig-name descname">triangles_center</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_center" title="Permalink to this definition">¶</a></dt>
<dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>triangles_center</strong> – Center of each triangular face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.faces), 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.triangles_cross">
<em class="property">property </em><code class="sig-name descname">triangles_cross</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>The cross product of two edges of each triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>crosses</strong> – Cross product of each triangle</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.triangles_tree">
<em class="property">property </em><code class="sig-name descname">triangles_tree</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree containing each face of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tree</strong> – Each triangle in self.faces has a rectangular cell</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rtree.index</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.union">
<code class="sig-name descname">union</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean union between this mesh and n other meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, or </em><em>list of trimesh.Trimesh objects</em>) – Other meshes to union</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong> – Union of self and other Trimesh objects</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.units">
<em class="property">property </em><code class="sig-name descname">units</code><a class="headerlink" href="#trimesh.base.Trimesh.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of units for the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>units</strong> – Unit system mesh is in, or None if not defined</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.unmerge_vertices">
<code class="sig-name descname">unmerge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.unmerge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all face references so that every face contains
three unique vertex indices and no faces are adjacent.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.update_faces">
<code class="sig-name descname">update_faces</code><span class="sig-paren">(</span><em class="sig-param">mask</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.update_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>In many cases, we will want to remove specific faces.
However, there is additional bookkeeping to do this cleanly.
This function updates the set of faces with a validity mask,
as well as keeping track of normals and colors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>valid</strong> – Mask to remove faces</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.update_vertices">
<code class="sig-name descname">update_vertices</code><span class="sig-paren">(</span><em class="sig-param">mask</em>, <em class="sig-param">inverse=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.update_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vertices with a mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertex_mask</strong> (<em>(</em><em>len</em><em>(</em><em>self.vertices</em><em>)</em><em>) </em><em>bool</em>) – Array of which vertices to keep</p></li>
<li><p><strong>inverse</strong> (<em>(</em><em>len</em><em>(</em><em>self.vertices</em><em>)</em><em>) </em><em>int</em>) – Array to reconstruct vertex references
such as output by np.unique</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.vertex_adjacency_graph">
<em class="property">property </em><code class="sig-name descname">vertex_adjacency_graph</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_adjacency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a networkx graph representing the vertices and their connections
in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>graph</strong> – Graph representing vertices and edges between
them where vertices are nodes and edges are edges</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>networkx.Graph</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<p>mesh = trimesh.primitives.Box()
graph = mesh.vertex_adjacency_graph
graph.neighbors(0)
&gt; [1,2,3,4]</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.vertex_defects">
<em class="property">property </em><code class="sig-name descname">vertex_defects</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_defects" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles
of every face that includes that vertex.</p>
<p>If a vertex is only included by coplanar triangles, this
will be zero. For convex regions this is positive, and
concave negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_defect</strong> – Vertex defect at the every vertex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), ) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.vertex_degree">
<em class="property">property </em><code class="sig-name descname">vertex_degree</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of faces each vertex is included in.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>degree</strong> – Number of faces each vertex is included in</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), ) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.vertex_faces">
<em class="property">property </em><code class="sig-name descname">vertex_faces</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>A representation of the face indices that correspond to each vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_faces</strong> – Each row contains the face indices that correspond to the given vertex,
padded with -1 up to the max number of faces corresponding to any one vertex
Where n == len(self.vertices), m == max number of faces for a single vertex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,m) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.vertex_neighbors">
<em class="property">property </em><code class="sig-name descname">vertex_neighbors</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex neighbors of each vertex of the mesh, determined from
the cached vertex_adjacency_graph, if already existent.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_neighbors</strong> – Represents immediate neighbors of each vertex along
the edge of a triangle</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices),) int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">Box</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1,2,3,4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.vertex_normals">
<em class="property">property </em><code class="sig-name descname">vertex_normals</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex normals of the mesh. If the normals were loaded
we check to make sure we have the same number of vertex
normals and vertices before returning them. If there are
no vertex normals defined or a shape mismatch we  calculate
the vertex normals from the mean normals of the faces the
vertex is used in.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_normals</strong> – Represents the surface normal at each vertex.
Where n == len(self.vertices)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.vertices">
<em class="property">property </em><code class="sig-name descname">vertices</code><a class="headerlink" href="#trimesh.base.Trimesh.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertices of the mesh.</p>
<p>This is regarded as core information which cannot be
generated from cache and as such is stored in self._data
which tracks the array for changes and clears cached
values of the mesh if this is altered.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertices</strong> – Points in cartesian space referenced by self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.visual">
<em class="property">property </em><code class="sig-name descname">visual</code><a class="headerlink" href="#trimesh.base.Trimesh.visual" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the stored visuals for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>visual</strong> – Contains visual information about the mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="trimesh.visual.html#trimesh.visual.color.ColorVisuals" title="trimesh.visual.color.ColorVisuals">ColorVisuals</a> or <a class="reference internal" href="trimesh.visual.html#trimesh.visual.texture.TextureVisuals" title="trimesh.visual.texture.TextureVisuals">TextureVisuals</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.volume">
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#trimesh.base.Trimesh.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the current mesh calculated using a surface
integral. If the current mesh isn’t watertight this is
garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>volume</strong> – Volume of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.voxelized">
<code class="sig-name descname">voxelized</code><span class="sig-paren">(</span><em class="sig-param">pitch</em>, <em class="sig-param">method='subdivide'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.voxelized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a VoxelGrid object representing the current mesh
discretized into voxels at the specified pitch</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pitch</strong> (<em>float</em>) – The edge length of a single voxel</p></li>
<li><p><strong>method</strong> (implementation key. See <cite>trimesh.voxel.creation.voxelizers</cite>) – </p></li>
<li><p><strong>**kwargs</strong> (<em>additional kwargs passed to the specified implementation.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>voxelized</strong> – Representing the current mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>VoxelGrid object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.boolean">
<span id="trimesh-boolean-module"></span><h2>trimesh.boolean module<a class="headerlink" href="#module-trimesh.boolean" title="Permalink to this headline">¶</a></h2>
<div class="section" id="boolean-py">
<h3>boolean.py<a class="headerlink" href="#boolean-py" title="Permalink to this headline">¶</a></h3>
<p>Do boolean operations on meshes using either Blender or OpenSCAD.</p>
<dl class="function">
<dt id="trimesh.boolean.boolean_automatic">
<code class="sig-prename descclassname">trimesh.boolean.</code><code class="sig-name descname">boolean_automatic</code><span class="sig-paren">(</span><em class="sig-param">meshes</em>, <em class="sig-param">operation</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.boolean_automatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically pick an engine for booleans based on availability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>meshes</strong> (<em>list of Trimesh</em>) – Meshes to be booleaned</p></li>
<li><p><strong>operation</strong> (<em>str</em>) – Type of boolean, i.e. ‘union’, ‘intersection’, ‘difference’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Result of boolean operation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.boolean.difference">
<code class="sig-prename descclassname">trimesh.boolean.</code><code class="sig-name descname">difference</code><span class="sig-paren">(</span><em class="sig-param">meshes</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean difference between a mesh an n other meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>meshes</strong> (<em>list of trimesh.Trimesh</em>) – Meshes to be processed</p></li>
<li><p><strong>engine</strong> (<em>str</em>) – Which backend to use, i.e. ‘blender’ or ‘scad’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>difference</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a - (other meshes), <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs for a Trimesh</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.boolean.intersection">
<code class="sig-prename descclassname">trimesh.boolean.</code><code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">meshes</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean intersection between a mesh an n other meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>meshes</strong> (<em>list of trimesh.Trimesh</em>) – Meshes to be processed</p></li>
<li><p><strong>engine</strong> (<em>str</em>) – Which backend to use, i.e. ‘blender’ or ‘scad’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intersection</strong> – volume that is contained by all meshes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs for a Trimesh object of the</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.boolean.union">
<code class="sig-prename descclassname">trimesh.boolean.</code><code class="sig-name descname">union</code><span class="sig-paren">(</span><em class="sig-param">meshes</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean union between a mesh an n other meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>meshes</strong> (<em>list of trimesh.Trimesh</em>) – Meshes to be processed</p></li>
<li><p><strong>engine</strong> (<em>str</em>) – Which backend to use, i.e. ‘blender’ or ‘scad’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a + (other meshes), <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs for a Trimesh</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.bounds">
<span id="trimesh-bounds-module"></span><h2>trimesh.bounds module<a class="headerlink" href="#module-trimesh.bounds" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.bounds.contains">
<code class="sig-prename descclassname">trimesh.bounds.</code><code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Do an axis aligned bounding box check on a list of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>(</em><em>2</em><em>, </em><em>dimension</em><em>) </em><em>float</em>) – Axis aligned bounding box</p></li>
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>dimension</em><em>) </em><em>float</em>) – Points in space</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points_inside</strong> – True if points are inside the AABB</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.corners">
<code class="sig-prename descclassname">trimesh.bounds.</code><code class="sig-name descname">corners</code><span class="sig-paren">(</span><em class="sig-param">bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pair of axis aligned bounds, return all
8 corners of the bounding box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bounds</strong> (<em>(</em><em>2</em><em>,</em><em>3</em><em>) or </em><em>(</em><em>2</em><em>,</em><em>2</em><em>) </em><em>float</em>) – Axis aligned bounds</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>corners</strong> – Corner vertices of the cube</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(8,3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.minimum_cylinder">
<code class="sig-prename descclassname">trimesh.bounds.</code><code class="sig-name descname">minimum_cylinder</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">sample_count=6</em>, <em class="sig-param">angle_tol=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.minimum_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the approximate minimum volume cylinder which contains
a mesh or a a list of points.</p>
<p>Samples a hemisphere then uses scipy.optimize to pick the
final orientation of the cylinder.</p>
<p>A nice discussion about better ways to implement this is here:
<a class="reference external" href="https://www.staff.uni-mainz.de/schoemer/publications/ALGO00.pdf">https://www.staff.uni-mainz.de/schoemer/publications/ALGO00.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, or </em><em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Mesh object or points in space</p></li>
<li><p><strong>sample_count</strong> (<em>int</em>) – How densely should we sample the hemisphere.
Angular spacing is 180 degrees / this number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> –</p>
<dl>
<dt>With keys:</dt><dd><p>’radius’    : float, radius of cylinder
‘height’    : float, height of cylinder
‘transform’ : (4,4) float, transform from the origin</p>
<blockquote>
<div><p>to centered cylinder</p>
</div></blockquote>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.oriented_bounds">
<code class="sig-prename descclassname">trimesh.bounds.</code><code class="sig-name descname">oriented_bounds</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">angle_digits=1</em>, <em class="sig-param">ordered=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.oriented_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the oriented bounding box for a Trimesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, </em><em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>float</em><em>, or </em><em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Mesh object or points in 2D or 3D space</p></li>
<li><p><strong>angle_digits</strong> (<em>int</em>) – How much angular precision do we want on our result.
Even with less precision the returned extents will cover
the mesh albeit with larger than minimal volume, and may
experience substantial speedups.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>to_origin</strong> (<em>(4,4) float</em>) – Transformation matrix which will move the center of the
bounding box of the input mesh to the origin.</p></li>
<li><p><strong>extents</strong> (<em>(3,) float</em>) – The extents of the mesh once transformed with to_origin</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.oriented_bounds_2D">
<code class="sig-prename descclassname">trimesh.bounds.</code><code class="sig-name descname">oriented_bounds_2D</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">qhull_options='QbB'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.oriented_bounds_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an oriented bounding box for an array of 2D points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>2</em><em>) </em><em>float</em>) – Points in 2D.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>transform</strong> (<em>(3,3) float</em>) – Homogeneous 2D transformation matrix to move the
input points so that the axis aligned bounding box
is CENTERED AT THE ORIGIN.</p></li>
<li><p><strong>rectangle</strong> (<em>(2,) float</em>) – Size of extents once input points are transformed
by transform</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.caching">
<span id="trimesh-caching-module"></span><h2>trimesh.caching module<a class="headerlink" href="#module-trimesh.caching" title="Permalink to this headline">¶</a></h2>
<div class="section" id="caching-py">
<h3>caching.py<a class="headerlink" href="#caching-py" title="Permalink to this headline">¶</a></h3>
<p>Functions and classes that help with tracking changes in ndarrays
and clearing cached values based on those changes.</p>
<dl class="class">
<dt id="trimesh.caching.Cache">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.caching.</code><code class="sig-name descname">Cache</code><span class="sig-paren">(</span><em class="sig-param">id_function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to cache values which will be stored until the
result of an ID function changes.</p>
<dl class="method">
<dt id="trimesh.caching.Cache.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all elements in the cache.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a key from the cache.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.id_set">
<code class="sig-name descname">id_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.id_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current ID to the value of the ID function.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">items</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the cache with a set of key, value pairs without
checking id_function.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.verify">
<code class="sig-name descname">verify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that the cached values are still for the same
value of id_function and delete all stored items if
the value of id_function has changed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.caching.DataStore">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.caching.</code><code class="sig-name descname">DataStore</code><a class="headerlink" href="#trimesh.caching.DataStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></p>
<p>A class to store multiple numpy arrays and track them all
for changes.</p>
<p>Operates like a dict that only stores numpy.ndarray</p>
<dl class="method">
<dt id="trimesh.caching.DataStore.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all data from the DataStore.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.crc">
<code class="sig-name descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a CRC reflecting everything in the DataStore.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>crc</strong> – CRC of data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.fast_hash">
<code class="sig-name descname">fast_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.fast_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a CRC32 or xxhash.xxh64 reflecting the DataStore.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>hashed</strong> – Checksum of data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.is_empty">
<code class="sig-name descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the current DataStore empty or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>empty</strong> – False if there are items in the DataStore</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.md5">
<code class="sig-name descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an MD5 reflecting everything in the DataStore.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>md5</strong> – MD5 of data in hexadecimal</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.mutable">
<em class="property">property </em><code class="sig-name descname">mutable</code><a class="headerlink" href="#trimesh.caching.DataStore.mutable" title="Permalink to this definition">¶</a></dt>
<dd><p>Is data allowed to be altered or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>is_mutable</strong> – Can data be altered in the DataStore</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">values</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.caching.TrackedArray">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.caching.</code><code class="sig-name descname">TrackedArray</code><a class="headerlink" href="#trimesh.caching.TrackedArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
<p>Subclass of numpy.ndarray that provides hash methods
to track changes.</p>
<p>General method is to aggressively set ‘modified’ flags
on operations which might (but don’t necessarily) alter
the array, ideally we sometimes compute hashes when we
don’t need to, but we don’t return wrong hashes ever.</p>
<p>We store boolean modified flag for each hash type to
make checks fast even for queries of different hashes.</p>
<dl class="method">
<dt>
<code class="sig-name descname">md5 :       str, hexadecimal MD5 of array</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">crc :       int, zlib crc32/adler32 checksum</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">fast_hash : int, CRC or xxhash.xx64</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.crc">
<code class="sig-name descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A zlib.crc32 or zlib.adler32 checksum
of the current data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>crc</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int, checksum from zlib.crc32 or zlib.adler32</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.fast_hash">
<code class="sig-name descname">fast_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.fast_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>An xxhash.b64 hash of the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>xx</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int, xxhash.xxh64 hash of array.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.md5">
<code class="sig-name descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an MD5 hash of the current array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>md5</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str, hexadecimal MD5 of the array</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.mutable">
<em class="property">property </em><code class="sig-name descname">mutable</code><a class="headerlink" href="#trimesh.caching.TrackedArray.mutable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.caching.cache_decorator">
<code class="sig-prename descclassname">trimesh.caching.</code><code class="sig-name descname">cache_decorator</code><span class="sig-paren">(</span><em class="sig-param">function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.cache_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator for class methods, replaces &#64;property
but will store and retrieve function return values
in object cache.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<em>method</em>) – <p>This is used as a decorator:
<a href="#id9"><span class="problematic" id="id10">``</span></a>`
&#64;cache_decorator
def foo(self, things):</p>
<blockquote>
<div><p>return ‘happy days’</p>
</div></blockquote>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a></p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.caching.tracked_array">
<code class="sig-prename descclassname">trimesh.caching.</code><code class="sig-name descname">tracked_array</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.tracked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Properly subclass a numpy ndarray to track changes.</p>
<p>Avoids some pitfalls of subclassing by forcing contiguous
arrays, and does a view into a TrackedArray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>array- like object</em>) – To be turned into a TrackedArray</p></li>
<li><p><strong>dtype</strong> (<em>np.dtype</em>) – Which dtype to use for the array</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tracked</strong> – Contains input array data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.caching.TrackedArray" title="trimesh.caching.TrackedArray">TrackedArray</a></p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.collision">
<span id="trimesh-collision-module"></span><h2>trimesh.collision module<a class="headerlink" href="#module-trimesh.collision" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.collision.CollisionManager">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.collision.</code><code class="sig-name descname">CollisionManager</code><a class="headerlink" href="#trimesh.collision.CollisionManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A mesh-mesh collision manager.</p>
<dl class="method">
<dt id="trimesh.collision.CollisionManager.add_object">
<code class="sig-name descname">add_object</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">mesh</em>, <em class="sig-param">transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.add_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an object to the collision manager.</p>
<p>If an object with the given name is already in the manager,
replace it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – An identifier for the object</p></li>
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – The geometry of the collision object</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – Homogeneous transform matrix for the object</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_internal">
<code class="sig-name descname">in_collision_internal</code><span class="sig-paren">(</span><em class="sig-param">return_names=False</em>, <em class="sig-param">return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any pair of objects in the manager collide with one another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>return_names</strong> (<em>bool</em>) – If true, a set is returned containing the names
of all pairs of objects in collision.</p></li>
<li><p><strong>return_data</strong> (<em>bool</em>) – If true, a list of ContactData is returned as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>is_collision</strong> (<em>bool</em>) – True if a collision occurred between any pair of objects
and False otherwise</p></li>
<li><p><strong>names</strong> (<em>set of 2-tup</em>) – The set of pairwise collisions. Each tuple
contains two names in alphabetical order indicating
that the two corresponding objects are in collision.</p></li>
<li><p><strong>contacts</strong> (<em>list of ContactData</em>) – All contacts detected</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_other">
<code class="sig-name descname">in_collision_other</code><span class="sig-paren">(</span><em class="sig-param">other_manager</em>, <em class="sig-param">return_names=False</em>, <em class="sig-param">return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any object from this manager collides with any object
from another manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other_manager</strong> (<a class="reference internal" href="#trimesh.collision.CollisionManager" title="trimesh.collision.CollisionManager"><em>CollisionManager</em></a>) – Another collision manager object</p></li>
<li><p><strong>return_names</strong> (<em>bool</em>) – If true, a set is returned containing the names
of all pairs of objects in collision.</p></li>
<li><p><strong>return_data</strong> (<em>bool</em>) – If true, a list of ContactData is returned as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>is_collision</strong> (<em>bool</em>) – True if a collision occurred between any pair of objects
and False otherwise</p></li>
<li><p><strong>names</strong> (<em>set of 2-tup</em>) – The set of pairwise collisions. Each tuple
contains two names (first from this manager,
second from the other_manager) indicating
that the two corresponding objects are in collision.</p></li>
<li><p><strong>contacts</strong> (<em>list of ContactData</em>) – All contacts detected</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_single">
<code class="sig-name descname">in_collision_single</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">transform=None</em>, <em class="sig-param">return_names=False</em>, <em class="sig-param">return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Check a single object for collisions against all objects in the
manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – The geometry of the collision object</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – Homogeneous transform matrix</p></li>
<li><p><strong>return_names</strong> (<em>bool</em>) – If true, a set is returned containing the names
of all objects in collision with the object</p></li>
<li><p><strong>return_data</strong> (<em>bool</em>) – If true, a list of ContactData is returned as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>is_collision</strong> (<em>bool</em>) – True if a collision occurs and False otherwise</p></li>
<li><p><strong>names</strong> (<em>set of str</em>) – The set of names of objects that collided with the
provided one</p></li>
<li><p><strong>contacts</strong> (<em>list of ContactData</em>) – All contacts detected</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_internal">
<code class="sig-name descname">min_distance_internal</code><span class="sig-paren">(</span><em class="sig-param">return_names=False</em>, <em class="sig-param">return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between any pair of objects in the manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>return_names</strong> (<em>bool</em>) – If true, a 2-tuple is returned containing the names
of the closest objects.</p></li>
<li><p><strong>return_data</strong> (<em>bool</em>) – If true, a DistanceData object is returned as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>distance</strong> (<em>float</em>) – Min distance between any two managed objects</p></li>
<li><p><strong>names</strong> (<em>(2,) str</em>) – The names of the closest objects</p></li>
<li><p><strong>data</strong> (<em>DistanceData</em>) – Extra data about the distance query</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_other">
<code class="sig-name descname">min_distance_other</code><span class="sig-paren">(</span><em class="sig-param">other_manager</em>, <em class="sig-param">return_names=False</em>, <em class="sig-param">return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between any pair of objects,
one in each manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other_manager</strong> (<a class="reference internal" href="#trimesh.collision.CollisionManager" title="trimesh.collision.CollisionManager"><em>CollisionManager</em></a>) – Another collision manager object</p></li>
<li><p><strong>return_names</strong> (<em>bool</em>) – If true, a 2-tuple is returned containing
the names of the closest objects.</p></li>
<li><p><strong>return_data</strong> (<em>bool</em>) – If true, a DistanceData object is returned as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>distance</strong> (<em>float</em>) – The min distance between a pair of objects,
one from each manager.</p></li>
<li><p><strong>names</strong> (<em>2-tup of str</em>) – A 2-tuple containing two names (first from this manager,
second from the other_manager) indicating
the two closest objects.</p></li>
<li><p><strong>data</strong> (<em>DistanceData</em>) – Extra data about the distance query</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_single">
<code class="sig-name descname">min_distance_single</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">transform=None</em>, <em class="sig-param">return_name=False</em>, <em class="sig-param">return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between a single object and any
object in the manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – The geometry of the collision object</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – Homogeneous transform matrix for the object</p></li>
<li><p><strong>return_names</strong> (<em>bool</em>) – If true, return name of the closest object</p></li>
<li><p><strong>return_data</strong> (<em>bool</em>) – If true, a DistanceData object is returned as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>distance</strong> (<em>float</em>) – Min distance between mesh and any object in the manager</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name of the object in the manager that was closest</p></li>
<li><p><strong>data</strong> (<em>DistanceData</em>) – Extra data about the distance query</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.remove_object">
<code class="sig-name descname">remove_object</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.remove_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete an object from the collision manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – The identifier for the object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.set_transform">
<code class="sig-name descname">set_transform</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.set_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transform for one of the manager’s objects.
This replaces the prior transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – An identifier for the object already in the manager</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – A new homogeneous transform matrix for the object</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.collision.ContactData">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.collision.</code><code class="sig-name descname">ContactData</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">contact</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.ContactData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Data structure for holding information about a collision contact.</p>
<dl class="method">
<dt id="trimesh.collision.ContactData.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.ContactData.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the face in contact for the mesh with
the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – The name of the target object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – The index of the face in collison</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.ContactData.point">
<em class="property">property </em><code class="sig-name descname">point</code><a class="headerlink" href="#trimesh.collision.ContactData.point" title="Permalink to this definition">¶</a></dt>
<dd><p>The 3D point of intersection for this contact.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>point</strong> – The intersection point.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.collision.DistanceData">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.collision.</code><code class="sig-name descname">DistanceData</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">result</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Data structure for holding information about a distance query.</p>
<dl class="method">
<dt id="trimesh.collision.DistanceData.distance">
<em class="property">property </em><code class="sig-name descname">distance</code><a class="headerlink" href="#trimesh.collision.DistanceData.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance between the two objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>distance</strong> – The euclidean distance between the objects.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.DistanceData.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the closest face for the mesh with
the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – The name of the target object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – The index of the face in collisoin.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.DistanceData.point">
<code class="sig-name descname">point</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData.point" title="Permalink to this definition">¶</a></dt>
<dd><p>The 3D point of closest distance on the mesh with the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – The name of the target object.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>point</strong> – The closest point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.collision.mesh_to_BVH">
<code class="sig-prename descclassname">trimesh.collision.</code><code class="sig-name descname">mesh_to_BVH</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.mesh_to_BVH" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a BVHModel object from a Trimesh object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a>) – Input geometry</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bvh</strong> – BVH of input geometry</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fcl.BVHModel</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.collision.scene_to_collision">
<code class="sig-prename descclassname">trimesh.collision.</code><code class="sig-name descname">scene_to_collision</code><span class="sig-paren">(</span><em class="sig-param">scene</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.scene_to_collision" title="Permalink to this definition">¶</a></dt>
<dd><p>Create collision objects from a trimesh.Scene object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scene</strong> (<a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene"><em>trimesh.Scene</em></a>) – Scene to create collision objects for</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>manager</strong> (<em>CollisionManager</em>) – CollisionManager for objects in scene</p></li>
<li><p><strong>objects</strong> (<em>{node name: CollisionObject}</em>) – Collision objects for nodes in scene</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.comparison">
<span id="trimesh-comparison-module"></span><h2>trimesh.comparison module<a class="headerlink" href="#module-trimesh.comparison" title="Permalink to this headline">¶</a></h2>
<div class="section" id="comparison-py">
<h3>comparison.py<a class="headerlink" href="#comparison-py" title="Permalink to this headline">¶</a></h3>
<p>Provide methods for quickly hashing and comparing meshes.</p>
<dl class="function">
<dt id="trimesh.comparison.face_ordering">
<code class="sig-prename descclassname">trimesh.comparison.</code><code class="sig-name descname">face_ordering</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.face_ordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangles with three different length sides are
ordered in two ways:
[small edge, medium edge, large edge] (SML)
[small edge, large edge,  medium edge] (SLM)</p>
<p>This function returns [-1, 0, 1], depending on whether
the triangle is SML or SLM, and 0 if M == L.</p>
<p>The reason this is useful as it as a rare property that is
invariant to translation and rotation but changes when a
mesh is reflected or inverted. It is NOT invariant to
different tesselations of the same surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Source geometry to calculate ordering on</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>order</strong> – Is each face SML (-1), SLM (+1), or M==L (0)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(len(mesh.faces), ) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.comparison.identifier_hash">
<code class="sig-prename descclassname">trimesh.comparison.</code><code class="sig-name descname">identifier_hash</code><span class="sig-paren">(</span><em class="sig-param">identifier</em>, <em class="sig-param">sigfig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.identifier_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash an identifier array to a specified number of
significant figures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identifier</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Vector of properties</p></li>
<li><p><strong>sigfig</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>int</em>) – Number of sigfigs per property</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>md5</strong> – MD5 hash of identifier</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.comparison.identifier_simple">
<code class="sig-prename descclassname">trimesh.comparison.</code><code class="sig-name descname">identifier_simple</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.identifier_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a basic identifier for a mesh, consisting of properties
that have been hand tuned to be somewhat robust to rigid
transformations and different tesselations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>Trimesh object</em>) – Source geometry</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>identifier</strong> – Identifying values of the mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(6,) float</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.constants">
<span id="trimesh-constants-module"></span><h2>trimesh.constants module<a class="headerlink" href="#module-trimesh.constants" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.constants.ResolutionPath">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.constants.</code><code class="sig-name descname">ResolutionPath</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.ResolutionPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="simple">
<dt>res.seg_frac: when discretizing curves, what percentage of the drawing</dt><dd><p>scale should we aim to make a single segment</p>
</dd>
</dl>
<p>res.seg_angle: when discretizing curves, what angle should a section span
res.max_sections: when discretizing splines, what is the maximum number</p>
<blockquote>
<div><p>of segments per control point</p>
</div></blockquote>
<dl class="simple">
<dt>res.min_sections: when discretizing splines, what is the minimum number</dt><dd><p>of segments per control point</p>
</dd>
</dl>
<p>res.export: format string to use when exporting floating point vertices</p>
</dd></dl>

<dl class="class">
<dt id="trimesh.constants.ToleranceMesh">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.constants.</code><code class="sig-name descname">ToleranceMesh</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.ToleranceMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>ToleranceMesh objects hold tolerance information about meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tol.zero</strong> (<em>float</em>) – Floating point numbers smaller than this are considered zero</p></li>
<li><p><strong>tol.merge</strong> (<em>float</em>) – When merging vertices, consider vertices closer than this
to be the same vertex. Here we use the same value (1e-8)
as SolidWorks uses, according to their documentation.</p></li>
<li><p><strong>tol.planar</strong> (<em>float</em>) – The maximum distance from a plane a point can be and
still be considered to be on the plane</p></li>
<li><p><strong>tol.facet_threshold</strong> (<em>float</em>) – Threshold for two facets to be considered coplanar</p></li>
<li><p><strong>tol.strict</strong> (<em>bool</em>) – If True, run additional in- process checks (slower)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="trimesh.constants.TolerancePath">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.constants.</code><code class="sig-name descname">TolerancePath</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.TolerancePath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>TolerancePath objects contain tolerance information used in
Path objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tol.zero</strong> (<em>float</em>) – Floating point numbers smaller than this are considered zero</p></li>
<li><p><strong>tol.merge</strong> (<em>float</em>) – When merging vertices, consider vertices closer than this
to be the same vertex. Here we use the same value (1e-8)
as SolidWorks uses, according to their documentation.</p></li>
<li><p><strong>tol.planar</strong> (<em>float</em>) – The maximum distance from a plane a point can be and
still be considered to be on the plane</p></li>
<li><p><strong>tol.seg_frac</strong> (<em>float</em>) – <dl class="simple">
<dt>When simplifying line segments what percentage of the drawing</dt><dd><p>scale can a segment be and have a curve fitted</p>
</dd>
</dl>
</p></li>
<li><p><strong>tol.seg_angle</strong> (<em>when simplifying line segments to arcs</em><em>, </em><em>what angle</em>) – can a segment span to be acceptable.</p></li>
<li><p><strong>tol.aspect_frac</strong> (<em>when simplifying line segments to closed arcs</em><em> (</em><em>circles</em><em>)</em>) – what percentage can the aspect ratio differfrom 1:1
before escaping the fit early</p></li>
<li><p><strong>tol.radius_frac</strong> (<em>when simplifying line segments to arcs</em><em>, </em><em>what percentage</em>) – of the fit radius can vertices deviate to be acceptable</p></li>
<li><p><strong>tol.radius_min</strong> (<em>when simplifying line segments to arcs</em><em>, </em><em>what is the minimum</em>) – radius multiplied by document scale for an acceptable fit</p></li>
<li><p><strong>tol.radius_max</strong> (<em>when simplifying line segments to arcs</em><em>, </em><em>what is the maximum</em>) – radius multiplied by document scale for an acceptable fit</p></li>
<li><p><strong>tol.tangent</strong> (<em>when simplifying line segments to curves</em><em>, </em><em>what is the maximum</em>) – angle the end sections can deviate from tangent that is acceptable.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.constants.log_time">
<code class="sig-prename descclassname">trimesh.constants.</code><code class="sig-name descname">log_time</code><span class="sig-paren">(</span><em class="sig-param">method</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.log_time" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator for methods which will time the method
and then emit a log.debug message with the method name
and how long it took to execute.</p>
</dd></dl>

</div>
<div class="section" id="module-trimesh.convex">
<span id="trimesh-convex-module"></span><h2>trimesh.convex module<a class="headerlink" href="#module-trimesh.convex" title="Permalink to this headline">¶</a></h2>
<p>convex.py</p>
<p>Deal with creating and checking convex objects in 2, 3 and N dimensions.</p>
<p>Convex is defined as:
1) “Convex, meaning “curving out” or “extending outward” (compare to concave)
2) having an outline or surface curved like the exterior of a circle or sphere.
3) (of a polygon) having only interior angles measuring less than 180</p>
<dl class="function">
<dt id="trimesh.convex.adjacency_projections">
<code class="sig-prename descclassname">trimesh.convex.</code><code class="sig-name descname">adjacency_projections</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.adjacency_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a mesh is convex by projecting the vertices of
a triangle onto the normal of its adjacent face.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a>) – Input geometry</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>projection</strong> – Distance of projection of adjacent vertex onto plane</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(len(mesh.face_adjacency),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.convex_hull">
<code class="sig-prename descclassname">trimesh.convex.</code><code class="sig-name descname">convex_hull</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">qhull_options='QbB Pp QJn'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Trimesh object representing the convex hull of the
current mesh, with proper normals and watertight.
Requires scipy &gt;.12.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a><em>, or </em><em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Mesh or cartesian points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>convex</strong> – Mesh of convex hull</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh">Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.hull_points">
<code class="sig-prename descclassname">trimesh.convex.</code><code class="sig-name descname">hull_points</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">qhull_options='QbB Pp'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.hull_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract a convex set of points from multiple input formats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>Trimesh object</em>) – (n,d) points
(m,) Trimesh objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(o,d) convex set of points</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.is_convex">
<code class="sig-prename descclassname">trimesh.convex.</code><code class="sig-name descname">is_convex</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is convex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a>) – Input geometry</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>convex</strong> – Was passed mesh convex or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.creation">
<span id="trimesh-creation-module"></span><h2>trimesh.creation module<a class="headerlink" href="#module-trimesh.creation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="creation-py">
<h3>creation.py<a class="headerlink" href="#creation-py" title="Permalink to this headline">¶</a></h3>
<p>Create meshes from primitives, or with operations.</p>
<dl class="function">
<dt id="trimesh.creation.annulus">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">annulus</code><span class="sig-paren">(</span><em class="sig-param">r_min=1.0</em>, <em class="sig-param">r_max=2.0</em>, <em class="sig-param">height=1.0</em>, <em class="sig-param">sections=32</em>, <em class="sig-param">transform=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.annulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of an annular cylinder along Z,
centered at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r_min</strong> (<em>float</em>) – The inner radius of the annular cylinder</p></li>
<li><p><strong>r_max</strong> (<em>float</em>) – The outer radius of the annular cylinder</p></li>
<li><p><strong>height</strong> (<em>float</em>) – The height of the annular cylinder</p></li>
<li><p><strong>sections</strong> (<em>int</em>) – How many pie wedges should the annular cylinder have</p></li>
<li><p><strong>**kwargs</strong> – passed to Trimesh to create annulus</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>annulus</strong> – Mesh of annular cylinder</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.axis">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">axis</code><span class="sig-paren">(</span><em class="sig-param">origin_size=0.04</em>, <em class="sig-param">transform=None</em>, <em class="sig-param">origin_color=None</em>, <em class="sig-param">axis_radius=None</em>, <em class="sig-param">axis_length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an XYZ axis marker as a  Trimesh, which represents position
and orientation. If you set the origin size the other parameters
will be set relative to it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Transformation matrix</p></li>
<li><p><strong>origin_size</strong> (<em>float</em>) – Radius of sphere that represents the origin</p></li>
<li><p><strong>origin_color</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em><em> or </em><em>int</em><em>, </em><em>uint8</em><em> or </em><em>float</em>) – Color of the origin</p></li>
<li><p><strong>axis_radius</strong> (<em>float</em>) – Radius of cylinder that represents x, y, z axis</p></li>
<li><p><strong>axis_length</strong> (<em>float</em>) – Length of cylinder that represents x, y, z axis</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>marker</strong> – Mesh geometry of axis indicators</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.box">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">box</code><span class="sig-paren">(</span><em class="sig-param">extents=None</em>, <em class="sig-param">transform=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.box" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cuboid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>extents</strong> (<em>float</em><em>, or </em><em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Edge lengths</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Transformation matrix</p></li>
<li><p><strong>**kwargs</strong> – passed to Trimesh to create box</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>geometry</strong> – Mesh of a cuboid</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.camera_marker">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">camera_marker</code><span class="sig-paren">(</span><em class="sig-param">camera</em>, <em class="sig-param">marker_height=0.4</em>, <em class="sig-param">origin_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.camera_marker" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a visual marker for a camera object, including an axis and FOV.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>camera</strong> (<em>trimesh.scene.Camera</em>) – Camera object with FOV and transform defined</p></li>
<li><p><strong>marker_height</strong> (<em>float</em>) – How far along the camera Z should FOV indicators be</p></li>
<li><p><strong>origin_size</strong> (<em>float</em>) – Sphere radius of the origin (default: marker_height / 10.0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>meshes</strong> – Contains Trimesh and Path3D objects which can be visualized</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.capsule">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">capsule</code><span class="sig-paren">(</span><em class="sig-param">height=1.0, radius=1.0, count=[32, 32]</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of a capsule, or a cylinder with hemispheric ends.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>height</strong> (<em>float</em>) – Center to center distance of two spheres</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the cylinder and hemispheres</p></li>
<li><p><strong>count</strong> (<em>(</em><em>2</em><em>,</em><em>) </em><em>int</em>) – Number of sections on latitude and longitude</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>capsule</strong> –</p>
<dl class="simple">
<dt>Capsule geometry with:</dt><dd><ul class="simple">
<li><p>cylinder axis is along Z</p></li>
<li><p>one hemisphere is centered at the origin</p></li>
<li><p>other hemisphere is centered along the Z axis at height</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.cylinder">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">cylinder</code><span class="sig-paren">(</span><em class="sig-param">radius=1.0</em>, <em class="sig-param">height=1.0</em>, <em class="sig-param">sections=32</em>, <em class="sig-param">segment=None</em>, <em class="sig-param">transform=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of a cylinder along Z centered at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> (<em>float</em>) – The radius of the cylinder</p></li>
<li><p><strong>height</strong> (<em>float</em>) – The height of the cylinder</p></li>
<li><p><strong>sections</strong> (<em>int</em>) – How many pie wedges should the cylinder have</p></li>
<li><p><strong>segment</strong> (<em>(</em><em>2</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Endpoints of axis, overrides transform and height</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Transform to apply</p></li>
<li><p><strong>**kwargs</strong> – passed to Trimesh to create cylinder</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cylinder</strong> – Resulting mesh of a cylinder</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.extrude_polygon">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">extrude_polygon</code><span class="sig-paren">(</span><em class="sig-param">polygon</em>, <em class="sig-param">height</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.extrude_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a 2D shapely polygon into a 3D mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polygon</strong> (<em>shapely.geometry.Polygon</em>) – 2D geometry to extrude</p></li>
<li><p><strong>height</strong> (<em>float</em>) – Distance to extrude polygon along Z</p></li>
<li><p><strong>**kwargs</strong> – passed to Trimesh</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Resulting extrusion as watertight body</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.extrude_triangulation">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">extrude_triangulation</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">faces</em>, <em class="sig-param">height</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.extrude_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a 2D triangulation into a watertight Trimesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>float</em>) – 2D vertices</p></li>
<li><p><strong>faces</strong> (<em>(</em><em>m</em><em>, </em><em>3</em><em>) </em><em>int</em>) – Triangle indexes of vertices</p></li>
<li><p><strong>height</strong> (<em>float</em>) – Distance to extrude triangulation</p></li>
<li><p><strong>**kwargs</strong> – passed to Trimesh</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh created from extrusion</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.icosahedron">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">icosahedron</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.icosahedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an icosahedron, a 20 faced polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>ico</strong> – Icosahederon centered at the origin.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.icosphere">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">icosphere</code><span class="sig-paren">(</span><em class="sig-param">subdivisions=3</em>, <em class="sig-param">radius=1.0</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.icosphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an isophere centered at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subdivisions</strong> (<em>int</em>) – How many times to subdivide the mesh.
Note that the number of faces will grow as function of
4 ** subdivisions, so you probably want to keep this under ~5</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Desired radius of sphere</p></li>
<li><p><strong>color</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em><em> or </em><em>uint8</em>) – Desired color of sphere</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ico</strong> – Meshed sphere</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.random_soup">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">random_soup</code><span class="sig-paren">(</span><em class="sig-param">face_count=100</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.random_soup" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random triangles as a Trimesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>face_count</strong> (<em>int</em>) – Number of faces desired in mesh</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>soup</strong> – Geometry with face_count random faces</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.sweep_polygon">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">sweep_polygon</code><span class="sig-paren">(</span><em class="sig-param">polygon</em>, <em class="sig-param">path</em>, <em class="sig-param">angles=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.sweep_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a 2D shapely polygon into a 3D mesh along an
arbitrary 3D path. Doesn’t handle sharp curvature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polygon</strong> (<em>shapely.geometry.Polygon</em>) – Profile to sweep along path</p></li>
<li><p><strong>path</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – A path in 3D</p></li>
<li><p><strong>angles</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Optional rotation angle relative to prior vertex
at each vertex</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Geometry of result</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.triangulate_polygon">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">triangulate_polygon</code><span class="sig-paren">(</span><em class="sig-param">polygon</em>, <em class="sig-param">triangle_args='pq30'</em>, <em class="sig-param">engine='auto'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.triangulate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a shapely polygon create a triangulation using one
of the python interfaces to triangle.c:
&gt; pip install meshpy
&gt; pip install triangle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polygon</strong> (<em>Shapely.geometry.Polygon</em>) – Polygon object to be triangulated</p></li>
<li><p><strong>triangle_args</strong> (<em>str</em>) – Passed to triangle.triangulate</p></li>
<li><p><strong>engine</strong> (<em>str</em>) – ‘meshpy’, ‘triangle’, or ‘auto’</p></li>
<li><p><strong>kwargs</strong> (<em>passed directly to meshpy.triangle.build:</em>) – <dl class="simple">
<dt>triangle.build(mesh_info,</dt><dd><p>verbose=False,
refinement_func=None,
attributes=False,
volume_constraints=True,
max_volume=None,
allow_boundary_steiner=True,
allow_volume_steiner=True,
quality_meshing=True,
generate_edges=None,
generate_faces=False,
min_angle=None)</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vertices</strong> (<em>(n, 2) float</em>) – Points in space</p></li>
<li><p><strong>faces</strong> (<em>(n, 3) int</em>) – Index of vertices that make up triangles</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.uv_sphere">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">uv_sphere</code><span class="sig-paren">(</span><em class="sig-param">radius=1.0, count=[32, 32], theta=None, phi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.uv_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UV sphere (latitude + longitude) centered at the
origin. Roughly one order of magnitude faster than an
icosphere but slightly uglier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> (<em>float</em>) – Radius of sphere</p></li>
<li><p><strong>count</strong> (<em>(</em><em>2</em><em>,</em><em>) </em><em>int</em>) – Number of latitude and longitude lines</p></li>
<li><p><strong>theta</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Optional theta angles in radians</p></li>
<li><p><strong>phi</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Optional phi angles in radians</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh of UV sphere with specified parameters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.validate_polygon">
<code class="sig-prename descclassname">trimesh.creation.</code><code class="sig-name descname">validate_polygon</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.validate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure an input can be returned as a valid polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>shapely.geometry.Polygon</em><em>, </em><em>str</em><em> (</em><em>wkb</em><em>)</em><em>, or </em><em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>float</em>) – Object which might be a polygon</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>polygon</strong> – Valid polygon object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>shapely.geometry.Polygon</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If a valid finite- area polygon isn’t available</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.curvature">
<span id="trimesh-curvature-module"></span><h2>trimesh.curvature module<a class="headerlink" href="#module-trimesh.curvature" title="Permalink to this headline">¶</a></h2>
<div class="section" id="curvature-py">
<h3>curvature.py<a class="headerlink" href="#curvature-py" title="Permalink to this headline">¶</a></h3>
<p>Query mesh curvature.</p>
<dl class="function">
<dt id="trimesh.curvature.discrete_gaussian_curvature_measure">
<code class="sig-prename descclassname">trimesh.curvature.</code><code class="sig-name descname">discrete_gaussian_curvature_measure</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em>, <em class="sig-param">radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.discrete_gaussian_curvature_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete gaussian curvature measure of a sphere centered
at a point as detailed in ‘Restricted Delaunay triangulations and normal
cycle’, Cohen-Steiner and Morvan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
<li><p><strong>radius</strong> (<em>float</em><em>, </em><em>the sphere radius</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>gaussian_curvature</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float, discrete gaussian curvature measure.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.discrete_mean_curvature_measure">
<code class="sig-prename descclassname">trimesh.curvature.</code><code class="sig-name descname">discrete_mean_curvature_measure</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em>, <em class="sig-param">radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.discrete_mean_curvature_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete mean curvature measure of a sphere centered
at a point as detailed in ‘Restricted Delaunay triangulations and normal
cycle’, Cohen-Steiner and Morvan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
<li><p><strong>radius</strong> (<em>float</em><em>, </em><em>the sphere radius</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mean_curvature</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float, discrete mean curvature measure.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.face_angles_sparse">
<code class="sig-prename descclassname">trimesh.curvature.</code><code class="sig-name descname">face_angles_sparse</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.face_angles_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the face angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sparse</strong> – dtype: float
shape: (len(mesh.vertices), len(mesh.faces))</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.sparse.coo_matrix with:</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.line_ball_intersection">
<code class="sig-prename descclassname">trimesh.curvature.</code><code class="sig-name descname">line_ball_intersection</code><span class="sig-paren">(</span><em class="sig-param">start_points</em>, <em class="sig-param">end_points</em>, <em class="sig-param">center</em>, <em class="sig-param">radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.line_ball_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the length of the intersection of a line segment with a ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
<li><p><strong>end_points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
<li><p><strong>center</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em><em>, </em><em>the sphere center</em>) – </p></li>
<li><p><strong>radius</strong> (<em>float</em><em>, </em><em>the sphere radius</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>lengths</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float, the lengths.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.sphere_ball_intersection">
<code class="sig-prename descclassname">trimesh.curvature.</code><code class="sig-name descname">sphere_ball_intersection</code><span class="sig-paren">(</span><em class="sig-param">R</em>, <em class="sig-param">r</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.sphere_ball_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the surface area of the intersection of sphere of radius R centered
at (0, 0, 0) with a ball of radius r centered at (R, 0, 0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>float</em><em>, </em><em>sphere radius</em>) – </p></li>
<li><p><strong>r</strong> (<em>float</em><em>, </em><em>ball radius</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>area</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, the surface are.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.vertex_defects">
<code class="sig-prename descclassname">trimesh.curvature.</code><code class="sig-name descname">vertex_defects</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.vertex_defects" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles
of every face that includes that vertex.</p>
<p>If a vertex is only included by coplanar triangles, this
will be zero. For convex regions this is positive, and
concave negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_defect</strong> – Vertex defect at the every vertex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), ) float</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.decomposition">
<span id="trimesh-decomposition-module"></span><h2>trimesh.decomposition module<a class="headerlink" href="#module-trimesh.decomposition" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.decomposition.convex_decomposition">
<code class="sig-prename descclassname">trimesh.decomposition.</code><code class="sig-name descname">convex_decomposition</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.decomposition.convex_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate convex decomposition of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Mesh to be decomposed into convex parts</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh_args</strong> – List of <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs for Trimeshes that are nearly
convex and approximate the original.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.exceptions">
<span id="trimesh-exceptions-module"></span><h2>trimesh.exceptions module<a class="headerlink" href="#module-trimesh.exceptions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exceptions-py">
<h3>exceptions.py<a class="headerlink" href="#exceptions-py" title="Permalink to this headline">¶</a></h3>
<p>Handle things related to exceptions.</p>
<dl class="class">
<dt id="trimesh.exceptions.ExceptionModule">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.exceptions.</code><code class="sig-name descname">ExceptionModule</code><span class="sig-paren">(</span><em class="sig-param">exc</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.exceptions.ExceptionModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Create a dummy module which will raise an exception when attributes
are accessed.</p>
<p>For soft dependencies we want to survive failing to import but
we would like to raise an appropriate error when the functionality is
actually requested so the user gets an easily debuggable message.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.exceptions.closure">
<code class="sig-prename descclassname">trimesh.exceptions.</code><code class="sig-name descname">closure</code><span class="sig-paren">(</span><em class="sig-param">exc</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.exceptions.closure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function which will accept any arguments
but raise the exception when called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>exc</strong> (<em>Exception</em>) – Will be raised later</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>failed</strong> – When called will raise <cite>exc</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.geometry">
<span id="trimesh-geometry-module"></span><h2>trimesh.geometry module<a class="headerlink" href="#module-trimesh.geometry" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.geometry.align_vectors">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">align_vectors</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">return_angle=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.align_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a transform between two 3D vectors.</p>
<p>Implements the method described here:
<a class="reference external" href="http://ethaneade.com/rot_between_vectors.pdf">http://ethaneade.com/rot_between_vectors.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Source vector</p></li>
<li><p><strong>b</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Target vector</p></li>
<li><p><strong>return_angle</strong> (<em>bool</em>) – If True return the angle between the two vectors</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>transform</strong> (<em>(4, 4) float</em>) – Homogeneous transform from a to b</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – Angle between vectors in radians
Only returned if return_angle</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.faces_to_edges">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">faces_to_edges</code><span class="sig-paren">(</span><em class="sig-param">faces</em>, <em class="sig-param">return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.faces_to_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of faces (n,3), return a list of edges (n*3,2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>faces</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>int</em>) – Vertex indices representing faces</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>edges</strong> – Vertex indices representing edges</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n*3, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.index_sparse">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">index_sparse</code><span class="sig-paren">(</span><em class="sig-param">columns</em>, <em class="sig-param">indices</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.index_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sparse matrix for which vertices are contained in which faces.
A data vector can be passed which is then used instead of booleans</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>columns</strong> (<em>int</em>) – Number of columns, usually number of vertices</p></li>
<li><p><strong>indices</strong> (<em>(</em><em>m</em><em>, </em><em>d</em><em>) </em><em>int</em>) – Usually mesh.faces</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sparse</strong> (<em>scipy.sparse.coo_matrix of shape (columns, len(faces))</em>) – dtype is boolean</p></li>
<li><p><em>Examples</em> – ———-</p></li>
<li><p><strong>In [1]</strong> (<em>sparse = faces_sparse(len(mesh.vertices), mesh.faces)</em>)</p></li>
<li><p><strong>In [2]</strong> (<em>sparse.shape</em>)</p></li>
<li><p><strong>Out[2]</strong> (<em>(12, 20)</em>)</p></li>
<li><p><strong>In [3]</strong> (<em>mesh.faces.shape</em>)</p></li>
<li><p><strong>Out[3]</strong> (<em>(20, 3)</em>)</p></li>
<li><p><strong>In [4]</strong> (<em>mesh.vertices.shape</em>)</p></li>
<li><p><strong>Out[4]</strong> (<em>(12, 3)</em>)</p></li>
<li><p><strong>In [5]</strong> (<em>dense = sparse.toarray().astype(int)</em>)</p></li>
<li><p><strong>In [6]</strong> (<em>dense</em>)</p></li>
<li><p><em>Out[6]</em></p></li>
<li><p><em>array([[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</em> – [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0],
[0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1],
[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0],
[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1],
[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1]])</p></li>
<li><p><strong>In [7]</strong> (<em>dense.sum(axis=0)</em>)</p></li>
<li><p><strong>Out[7]</strong> (<em>array([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.mean_vertex_normals">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">mean_vertex_normals</code><span class="sig-paren">(</span><em class="sig-param">vertex_count</em>, <em class="sig-param">faces</em>, <em class="sig-param">face_normals</em>, <em class="sig-param">sparse=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.mean_vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Find vertex normals from the mean of the faces that contain
that vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertex_count</strong> (<em>int</em>) – The number of vertices faces refer to</p></li>
<li><p><strong>faces</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>int</em>) – List of vertex indices</p></li>
<li><p><strong>face_normals</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Normal vector for each face</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vertex_normals</strong> – Normals for every vertex
Vertices unreferenced by faces will be zero.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(vertex_count, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.plane_transform">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">plane_transform</code><span class="sig-paren">(</span><em class="sig-param">origin</em>, <em class="sig-param">normal</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.plane_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the origin and normal of a plane find the transform
that will move that plane to be coplanar with the XY plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point that lies on the plane</p></li>
<li><p><strong>normal</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Vector that points along normal of plane</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transform</strong> – Transformation matrix to move points onto XY plane</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(4,4) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.triangulate_quads">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">triangulate_quads</code><span class="sig-paren">(</span><em class="sig-param">quads</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.triangulate_quads" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of quad faces, return them as triangle faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>quads</strong> (<em>(</em><em>n</em><em>, </em><em>4</em><em>) </em><em>int</em>) – Vertex indices of quad faces</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>faces</strong> – Vertex indices of triangular faces</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m, 3) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.vector_angle">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">vector_angle</code><span class="sig-paren">(</span><em class="sig-param">pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.vector_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the angles between pairs of unit vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pairs</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Unit vector pairs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>angles</strong> – Angles between vectors in radians</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.vertex_face_indices">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">vertex_face_indices</code><span class="sig-paren">(</span><em class="sig-param">vertex_count</em>, <em class="sig-param">faces</em>, <em class="sig-param">sparse=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.vertex_face_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Find vertex face indices from the faces array of vertices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertex_count</strong> (<em>int</em>) – The number of vertices faces refer to</p></li>
<li><p><strong>faces</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>int</em>) – List of vertex indices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vertex_faces</strong> – Face indices for every vertex
Array padded with -1 in each row for all vertices with fewer
face indices than the max number of face indices.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(vertex_count, ) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.weighted_vertex_normals">
<code class="sig-prename descclassname">trimesh.geometry.</code><code class="sig-name descname">weighted_vertex_normals</code><span class="sig-paren">(</span><em class="sig-param">vertex_count</em>, <em class="sig-param">faces</em>, <em class="sig-param">face_normals</em>, <em class="sig-param">face_angles</em>, <em class="sig-param">use_loop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.weighted_vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute vertex normals from the faces that contain that vertex.
The contibution of a face’s normal to a vertex normal is the
ratio of the corner-angle in which the vertex is, with respect
to the sum of all corner-angles surrounding the vertex.</p>
<p>Grit Thuerrner &amp; Charles A. Wuethrich (1998)
Computing Vertex Normals from Polygonal Facets,
Journal of Graphics Tools, 3:1, 43-46</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertex_count</strong> (<em>int</em>) – The number of vertices faces refer to</p></li>
<li><p><strong>faces</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>int</em>) – List of vertex indices</p></li>
<li><p><strong>face_normals</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Normal vector for each face</p></li>
<li><p><strong>face_angles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Angles at each vertex in the face</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vertex_normals</strong> – Normals for every vertex
Vertices unreferenced by faces will be zero.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(vertex_count, 3) float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.graph">
<span id="trimesh-graph-module"></span><h2>trimesh.graph module<a class="headerlink" href="#module-trimesh.graph" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graph-py">
<h3>graph.py<a class="headerlink" href="#graph-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with graph operations. Primarily deal with graphs in (n,2)
edge list form, and abstract the backend graph library being used.</p>
<p>Currently uses networkx, scipy.sparse.csgraph, or graph_tool
backends.</p>
<dl class="function">
<dt id="trimesh.graph.connected_component_labels">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">connected_component_labels</code><span class="sig-paren">(</span><em class="sig-param">edges</em>, <em class="sig-param">node_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_component_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Label graph nodes from an edge list, using scipy.sparse.csgraph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>int</em>) – Edges of a graph</p></li>
<li><p><strong>node_count</strong> (<em>int</em><em>, or </em><em>None</em>) – The largest node in the graph.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>labels</strong> – Component labels for each node</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(node_count,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.connected_components">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">connected_components</code><span class="sig-paren">(</span><em class="sig-param">edges</em>, <em class="sig-param">min_len=1</em>, <em class="sig-param">nodes=None</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Find groups of connected nodes from an edge list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> (<em>(</em><em>n</em><em>,</em><em>2</em><em>) </em><em>int</em><em>, </em><em>edges between nodes</em>) – </p></li>
<li><p><strong>nodes</strong> (<em>(</em><em>m</em><em>, </em><em>) </em><em>int</em><em>, </em><em>list of nodes that exist</em>) – </p></li>
<li><p><strong>min_len</strong> (<em>int</em><em>, </em><em>minimum length of a component group to return</em>) – </p></li>
<li><p><strong>engine</strong> (<em>str</em><em>, </em><em>which graph engine to use.</em>) – (‘networkx’, ‘scipy’, or ‘graphtool’)
If None, will automatically choose fastest available.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>components</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) sequence of lists, nodes which are connected</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.connected_edges">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">connected_edges</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given graph G and list of nodes, return the list of edges that
are connected to nodes</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.edges_to_coo">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">edges_to_coo</code><span class="sig-paren">(</span><em class="sig-param">edges</em>, <em class="sig-param">count=None</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.edges_to_coo" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an edge list, return a boolean scipy.sparse.coo_matrix
representing the edges in matrix form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> (<em>(</em><em>n</em><em>,</em><em>2</em><em>) </em><em>int</em>) – Edges of a graph</p></li>
<li><p><strong>count</strong> (<em>int</em>) – The total number of nodes in the graph
if None: count = edges.max() + 1</p></li>
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>any</em>) – Assign data to each edge, if None will
be bool True for each specified edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>matrix</strong> – Sparse COO</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(count, count) scipy.sparse.coo_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">face_adjacency</code><span class="sig-paren">(</span><em class="sig-param">faces=None</em>, <em class="sig-param">mesh=None</em>, <em class="sig-param">return_edges=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an (n,2) list of face indices.
Each pair of faces in the list shares an edge, making them adjacent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>faces</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>int</em><em>, or </em><em>None</em>) – List of vertex indices representing triangles</p></li>
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – If passed will used cached edges instead of faces</p></li>
<li><p><strong>return_edges</strong> (<em>bool</em>) – Return the edges shared by adjacent faces</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>adjacency</strong> (<em>(m,2) int</em>) – Indexes of faces that are adjacent</p></li>
<li><p><strong>edges</strong> (<em>(m,2) int</em>) – Only returned if return_edges is True
Indexes of vertices which make up the
edges shared by the adjacent faces</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for lots of things such as finding
face- connected components:
&gt;&gt;&gt; graph = nx.Graph()
&gt;&gt;&gt; graph.add_edges_from(mesh.face_adjacency)
&gt;&gt;&gt; groups = nx.connected_components(graph_connected)</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency_radius">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">face_adjacency_radius</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate radius between adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>radii</strong> (<em>(len(self.face_adjacency),) float</em>) – Approximate radius between faces
Parallel faces will have a value of np.inf</p></li>
<li><p><strong>span</strong> (<em>(len(self.face_adjacency),) float</em>) – Perpendicular projection distance of two
unshared vertices onto the shared edge</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency_unshared">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">face_adjacency_unshared</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency_unshared" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex index of the two vertices not in the shared
edge between two adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vid_unshared</strong> – Indexes of mesh.vertices</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(len(mesh.face_adjacency), 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.facets">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">facets</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the list of parallel adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – </p></li>
<li><p><strong>engine</strong> (<em>str</em>) – Which graph engine to use:
(‘scipy’, ‘networkx’, ‘graphtool’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>facets</strong> – Groups of face indexes of
parallel adjacent faces.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sequence of (n,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.fill_traversals">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">fill_traversals</code><span class="sig-paren">(</span><em class="sig-param">traversals</em>, <em class="sig-param">edges</em>, <em class="sig-param">edges_hash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.fill_traversals" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a traversal of a list of edges into a sequence of
traversals where every pair of consecutive node indexes
is an edge in a passed edge list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traversals</strong> (<em>sequence of</em><em> (</em><em>m</em><em>,</em><em>) </em><em>int</em>) – Node indexes of traversals of a graph</p></li>
<li><p><strong>edges</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>int</em>) – Pairs of connected node indexes</p></li>
<li><p><strong>edges_hash</strong> (<em>None</em><em>, or </em><em>(</em><em>n</em><em>,</em><em>) </em><em>int</em>) – Edges sorted along axis 1 then hashed
using grouping.hashable_rows</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>splits</strong> – Node indexes of connected traversals</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sequence of (p,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.graph_to_svg">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">graph_to_svg</code><span class="sig-paren">(</span><em class="sig-param">graph</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.graph_to_svg" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a networkx graph into an SVG string, using graphviz dot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>graph</strong> (<em>networkx graph</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>svg</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>string, pictoral layout in SVG format</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.is_watertight">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">is_watertight</code><span class="sig-paren">(</span><em class="sig-param">edges</em>, <em class="sig-param">edges_sorted=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.is_watertight" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>int</em>) – List of vertex indices</p></li>
<li><p><strong>edges_sorted</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>int</em>) – Pass vertex indices sorted on axis 1 as a speedup</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>watertight</strong> (<em>boolean</em>) – Whether every edge is shared by an even
number of faces</p></li>
<li><p><strong>winding</strong> (<em>boolean</em>) – Whether every shared edge is reversed</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.multigraph_collect">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">multigraph_collect</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">traversal</em>, <em class="sig-param">attrib=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.multigraph_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a MultiDiGraph traversal, collect attributes along it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkx.MultiDiGraph</em>) – </p></li>
<li><p><strong>traversal</strong> – </p></li>
<li><p><strong>attrib</strong> (<em>dict key</em><em>, </em><em>name to collect. If None</em><em>, </em><em>will return all</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>collected</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(len(traversal) - 1) list of attributes</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.multigraph_paths">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">multigraph_paths</code><span class="sig-paren">(</span><em class="sig-param">G</em>, <em class="sig-param">source</em>, <em class="sig-param">cutoff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.multigraph_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>For a networkx MultiDiGraph, find all paths from a source node
to leaf nodes. This function returns edge instance numbers
in addition to nodes, unlike networkx.all_simple_paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkx.MultiDiGraph</em>) – Graph to evaluate</p></li>
<li><p><strong>source</strong> (<em>hashable</em>) – Node to start traversal at</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Number of nodes to visit
If None will visit all nodes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>traversals</strong> – Traversals of the multigraph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) list of [(node, edge instance index), ] paths</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.shared_edges">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">shared_edges</code><span class="sig-paren">(</span><em class="sig-param">faces_a</em>, <em class="sig-param">faces_b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.shared_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two sets of faces, find the edges which are in both sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>faces_a</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>int</em><em>, </em><em>set of faces</em>) – </p></li>
<li><p><strong>faces_b</strong> (<em>(</em><em>m</em><em>,</em><em>3</em><em>) </em><em>int</em><em>, </em><em>set of faces</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>shared</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(p, 2) int, set of edges</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.smoothed">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">angle</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a non- watertight version of the mesh which will
render nicely with smooth shading by disconnecting faces
at sharp angles to each other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Source geometry</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – Angle in radians, adjacent faces which have normals
below this angle will be smoothed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>smooth</strong> – Geometry with disconnected face patches</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.split">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">only_watertight=True</em>, <em class="sig-param">adjacency=None</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a mesh into multiple meshes from face connectivity.</p>
<p>If only_watertight is true, it will only return watertight meshes
and will attempt single triangle/quad repairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a>) – </p></li>
<li><p><strong>only_watertight</strong> (<em>if True</em><em>, </em><em>only return watertight components</em>) – </p></li>
<li><p><strong>adjacency</strong> (<em>(</em><em>n</em><em>,</em><em>2</em><em>) </em><em>list of face adjacency to override using the plain</em>) – adjacency calculated automatically.</p></li>
<li><p><strong>engine</strong> (<em>str</em><em>, </em><em>which engine to use.</em><em> (</em><em>'networkx'</em><em>, </em><em>'scipy'</em><em>, or </em><em>'graphtool'</em><em>)</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>meshes</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of Trimesh objects</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.split_traversal">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">split_traversal</code><span class="sig-paren">(</span><em class="sig-param">traversal</em>, <em class="sig-param">edges</em>, <em class="sig-param">edges_hash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.split_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a traversal as a list of nodes, split the traversal
if a sequential index pair is not in the given edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>int</em>) – Graph edge indexes</p></li>
<li><p><strong>traversal</strong> (<em>(</em><em>m</em><em>,</em><em>) </em><em>int</em>) – Traversal through edges</p></li>
<li><p><strong>edge_hash</strong> (<em>(</em><em>n</em><em>,</em><em>)</em>) – Edges sorted on axis=1 and
passed to grouping.hashable_rows</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>split</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sequence of (p,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.traversals">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">traversals</code><span class="sig-paren">(</span><em class="sig-param">edges</em>, <em class="sig-param">mode='bfs'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.traversals" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an edge list, generate a sequence of ordered
depth first search traversals, using scipy.csgraph routines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> (<em>(</em><em>n</em><em>,</em><em>2</em><em>) </em><em>int</em><em>, </em><em>undirected edges of a graph</em>) – </p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>'bfs'</em><em>, or </em><em>'dfs'</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>traversals</strong> – ordered DFS or BFS traversals of the graph.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m,) sequence of (p,) int,</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.vertex_adjacency_graph">
<code class="sig-prename descclassname">trimesh.graph.</code><code class="sig-name descname">vertex_adjacency_graph</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.vertex_adjacency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a networkx graph representing the vertices and
their connections in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>graph</strong> – Graph representing vertices and edges between
them where vertices are nodes and edges are edges</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>networkx.Graph</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.
&gt;&gt;&gt; graph = mesh.vertex_adjacency_graph
&gt;&gt;&gt; graph.neighbors(0)
&gt; [1,3,4]</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.grouping">
<span id="trimesh-grouping-module"></span><h2>trimesh.grouping module<a class="headerlink" href="#module-trimesh.grouping" title="Permalink to this headline">¶</a></h2>
<div class="section" id="grouping-py">
<h3>grouping.py<a class="headerlink" href="#grouping-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for grouping values and rows.</p>
<dl class="function">
<dt id="trimesh.grouping.blocks">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">blocks</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">min_len=2</em>, <em class="sig-param">max_len=inf</em>, <em class="sig-param">wrap=False</em>, <em class="sig-param">digits=None</em>, <em class="sig-param">only_nonzero=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array, find the indices of contiguous blocks
of equal values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>array</em>) – Data to find blocks on</p></li>
<li><p><strong>min_len</strong> (<em>int</em>) – The minimum length group to be returned</p></li>
<li><p><strong>max_len</strong> (<em>int</em>) – The maximum length group to be retuurned</p></li>
<li><p><strong>wrap</strong> (<em>bool</em>) – Combine blocks on both ends of 1D array</p></li>
<li><p><strong>digits</strong> (<em>None</em><em> or </em><em>int</em>) – If dealing with floats how many digits to consider</p></li>
<li><p><strong>only_nonzero</strong> (<em>bool</em>) – Only return blocks of non- zero values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>blocks</strong> – Indices referencing data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><ol class="loweralpha simple" start="13">
<li><p>sequence of (<a href="#id17"><span class="problematic" id="id18">*</span></a>,) int</p></li>
</ol>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.boolean_rows">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">boolean_rows</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">operation=&lt;function intersect1d&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.boolean_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the rows in two arrays which occur in both rows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>int</em>) – Array with row vectors</p></li>
<li><p><strong>b</strong> (<em>(</em><em>m</em><em>, </em><em>d</em><em>) </em><em>int</em>) – Array with row vectors</p></li>
<li><p><strong>operation</strong> (<em>function</em>) – <dl class="simple">
<dt>Numpy boolean set operation function:</dt><dd><p>-np.intersect1d
-np.setdiff1d</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>shared</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(p, d) array containing rows in both a and b</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.clusters">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">clusters</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Find clusters of points which have neighbours closer than radius</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Points of dimension d</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Max distance between points in a cluster</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>groups</strong> – Indices of points in a cluster</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m,) sequence of int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.float_to_int">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">float_to_int</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">digits=None</em>, <em class="sig-param">dtype=&lt;class 'numpy.int32'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.float_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a numpy array of float/bool/int, return as integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em><em>, </em><em>int</em><em>, or </em><em>bool</em>) – Input data</p></li>
<li><p><strong>digits</strong> (<em>float</em><em> or </em><em>int</em>) – Precision for float conversion</p></li>
<li><p><strong>dtype</strong> (<em>numpy.dtype</em>) – What datatype should result be returned as</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>as_int</strong> – Data as integers</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, d) int</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">group</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">min_len=0</em>, <em class="sig-param">max_len=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of values that are identical</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>1D array</em>) – </p></li>
<li><p><strong>min_len</strong> (<em>int</em><em>, </em><em>the shortest group allowed</em>) – All groups will have len &gt;= min_length</p></li>
<li><p><strong>max_len</strong> (<em>int</em><em>, </em><em>the longest group allowed</em>) – All groups will have len &lt;= max_length</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>groups</strong> – IE [0,1,0,1] returns [[0,2], [1,3]]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sequence of indices to form groups</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_distance">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">group_distance</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find groups of points which have neighbours closer than radius,
where no two points in a group are farther than distance apart.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Points of dimension d</p></li>
<li><p><strong>distance</strong> (<em>float</em>) – Max distance between points in a cluster</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>unique</strong> (<em>(m, d) float</em>) – Median value of each group</p></li>
<li><p><strong>groups</strong> (<em>(m) sequence of int</em>) – Indexes of points that make up a group</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_min">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">group_min</code><span class="sig-paren">(</span><em class="sig-param">groups</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of groups find the minimum element of data
within each group</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>groups</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>sequence of</em><em> (</em><em>q</em><em>,</em><em>) </em><em>int</em>) – Indexes of each group corresponding to each element in data</p></li>
<li><p><strong>data</strong> (<em>(</em><em>m</em><em>,</em><em>)</em>) – The data that groups indexes reference</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>minimums</strong> – Minimum value of data per group</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_rows">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">group_rows</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">require_count=None</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns index groups of duplicate rows, for example:
[[1,2], [3,4], [1,2]] will return [[0,2], [1]]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>,</em><em>m</em><em>) </em><em>array</em>) – </p></li>
<li><p><strong>require_count</strong> (<em>only returns groups of a specified length</em><em>, </em><em>eg:</em>) – <p>require_count =  2
[[1,2], [3,4], [1,2]] will return [[0,2]]</p>
<p>Note that using require_count allows numpy advanced indexing
to be used in place of looping and checking hashes, and as a
consequence is ~10x faster.</p>
</p></li>
<li><p><strong>digits</strong> (<em>If data is floating point</em><em>, </em><em>how many decimals to look at.</em>) – If this is None, the value in TOL_MERGE will be turned into a
digit count and used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>groups</strong> – If require_count != None, shape will be (j, require_count)
If require_count is None, shape will be irregular (AKA a sequence)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List or sequence of indices from data indicating identical rows.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_vectors">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">group_vectors</code><span class="sig-paren">(</span><em class="sig-param">vectors</em>, <em class="sig-param">angle=0.0001</em>, <em class="sig-param">include_negative=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Group vectors based on an angle tolerance, with the option to
include negative vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Direction vector</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – Group vectors closer than this angle in radians</p></li>
<li><p><strong>include_negative</strong> (<em>bool</em>) – If True consider the same:
[0,0,1] and [0,0,-1]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>new_vectors</strong> (<em>(m,3) float</em>) – Direction vector</p></li>
<li><p><strong>groups</strong> (<em>(m,) sequence of int</em>) – Indices of source vectors</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.hashable_rows">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">hashable_rows</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.hashable_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>We turn our array into integers based on the precision
given by digits and then put them in a hashable format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>, </em><em>m</em><em>) </em><em>array</em>) – Input data</p></li>
<li><p><strong>digits</strong> (<em>int</em><em> or </em><em>None</em>) – How many digits to add to hash if data is floating point
If None, tol.merge will be used</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hashable</strong> – Custom data type which can be sorted
or used as hash keys</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.merge_runs">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">merge_runs</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.merge_runs" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge duplicate sequential values. This differs from unique_ordered
in that values can occur in multiple places in the sequence, but
only consecutive repeats are removed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em><em> or </em><em>int</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>merged</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m,) float or int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: a
Out[1]:
array([-1, -1, -1,  0,  0,  1,  1,  2,  0,</p>
<blockquote>
<div><p>3,  3,  4,  4,  5,  5,  6,  6,  7,
7,  8,  8,  9,  9,  9])</p>
</div></blockquote>
<p>In [2]: trimesh.grouping.merge_runs(a)
Out[2]: array([-1,  0,  1,  2,  0,  3,  4,  5,  6,  7,  8,  9])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.merge_vertices">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">merge_vertices</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">digits=None</em>, <em class="sig-param">textured=True</em>, <em class="sig-param">uv_digits=4</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes duplicate vertices based on integer hashes of
each row.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – Mesh to merge vertices on</p></li>
<li><p><strong>digits</strong> (<em>int</em>) – How many digits to consider for vertices
If not specified uses tol.merge</p></li>
<li><p><strong>textured</strong> (<em>bool</em>) – If True, for textured meshes only merge vertices
with identical positions AND UV coordinates.
No effect on untextured meshes</p></li>
<li><p><strong>uv_digits</strong> (<em>int</em>) – Number of digits to consider for UV coordinates.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_bincount">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">unique_bincount</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">minlength=0</em>, <em class="sig-param">return_inverse=False</em>, <em class="sig-param">return_counts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_bincount" title="Permalink to this definition">¶</a></dt>
<dd><p>For arrays of integers find unique values using bin counting.
Roughly 10x faster for correct input than np.unique</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>int</em>) – Values to find unique members of</p></li>
<li><p><strong>minlength</strong> (<em>int</em>) – Maximum value that will occur in values (values.max())</p></li>
<li><p><strong>return_inverse</strong> (<em>bool</em>) – If True, return an inverse such that unique[inverse] == values</p></li>
<li><p><strong>return_counts</strong> (<em>bool</em>) – If True, also return the number of times each unique item appears in values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>unique</strong> (<em>(m,) int</em>) – Unique values in original array</p></li>
<li><p><strong>inverse</strong> (<em>(n,) int, optional</em>) – An array such that unique[inverse] == values
Only returned if return_inverse is True</p></li>
<li><p><strong>counts</strong> (<em>(m,) int, optional</em>) – An array holding the counts of each unique item in values
Only returned if return_counts is True</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_float">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">unique_float</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">return_index=False</em>, <em class="sig-param">return_inverse=False</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to the numpy.unique command, except evaluates floating point
numbers, using a specified number of digits.</p>
<p>If digits isn’t specified, the library default TOL_MERGE will be used.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_ordered">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">unique_ordered</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_ordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the same as np.unique, but ordered as per the
first occurrence of the unique value in data.</p>
<p class="rubric">Examples</p>
<p>In [1]: a = [0, 3, 3, 4, 1, 3, 0, 3, 2, 1]</p>
<p>In [2]: np.unique(a)
Out[2]: array([0, 1, 2, 3, 4])</p>
<p>In [3]: trimesh.grouping.unique_ordered(a)
Out[3]: array([0, 3, 4, 1, 2])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_rows">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">unique_rows</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indices of unique rows. It will return the
first occurrence of a row that is duplicated:
[[1,2], [3,4], [1,2]] will return [0,1]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>,</em><em>m</em><em>) </em><em>set of floating point data</em>) – </p></li>
<li><p><strong>digits</strong> (<em>how many digits to consider for the purposes of uniqueness</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>unique</strong> (<em>(j) array, index in data which is a unique row</em>)</p></li>
<li><p><strong>inverse</strong> (<em>(n) length array to reconstruct original</em>) – example: unique[inverse] == data</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_value_in_row">
<code class="sig-prename descclassname">trimesh.grouping.</code><code class="sig-name descname">unique_value_in_row</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">unique=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_value_in_row" title="Permalink to this definition">¶</a></dt>
<dd><p>For a 2D array of integers find the position of a value in each
row which only occurs once. If there are more than one value per
row which occur once, the last one is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>,</em><em>d</em><em>) </em><em>int</em>) – </p></li>
<li><p><strong>unique</strong> – speedup purposes only, generated from np.unique if not passed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,d) bool, with one or zero True values per row.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<dl class="simple">
<dt>In [0]: r = np.array([[-1,  1,  1],</dt><dd><p>[-1,  1, -1],
[-1,  1,  1],
[-1,  1, -1],
[-1,  1, -1]], dtype=np.int8)</p>
</dd>
</dl>
<p>In [1]: unique_value_in_row(r)
Out[1]:</p>
<blockquote>
<div><dl class="simple">
<dt>array([[ True, False, False],</dt><dd><p>[False,  True, False],
[ True, False, False],
[False,  True, False],
[False,  True, False]], dtype=bool)</p>
</dd>
</dl>
</div></blockquote>
<p>In [2]: unique_value_in_row(r).sum(axis=1)
Out[2]: array([1, 1, 1, 1, 1])</p>
<p>In [3]: r[unique_value_in_row(r)]
Out[3]: array([-1,  1, -1,  1,  1], dtype=int8)</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.inertia">
<span id="trimesh-inertia-module"></span><h2>trimesh.inertia module<a class="headerlink" href="#module-trimesh.inertia" title="Permalink to this headline">¶</a></h2>
<div class="section" id="inertia-py">
<h3>inertia.py<a class="headerlink" href="#inertia-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for dealing with inertia tensors.</p>
<p>Results validated against known geometries and checked for
internal consistency.</p>
<dl class="function">
<dt id="trimesh.inertia.cylinder_inertia">
<code class="sig-prename descclassname">trimesh.inertia.</code><code class="sig-name descname">cylinder_inertia</code><span class="sig-paren">(</span><em class="sig-param">mass</em>, <em class="sig-param">radius</em>, <em class="sig-param">height</em>, <em class="sig-param">transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.cylinder_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inertia tensor of a cylinder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mass</strong> (<em>float</em>) – Mass of cylinder</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of cylinder</p></li>
<li><p><strong>height</strong> (<em>float</em>) – Height of cylinder</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – Transformation of cylinder</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>inertia</strong> – Inertia tensor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3,3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.principal_axis">
<code class="sig-prename descclassname">trimesh.inertia.</code><code class="sig-name descname">principal_axis</code><span class="sig-paren">(</span><em class="sig-param">inertia</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.principal_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the principal components and principal axis
of inertia from the inertia tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inertia</strong> (<em>(</em><em>3</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Inertia tensor</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>components</strong> (<em>(3,) float</em>) – Principal components of inertia</p></li>
<li><p><strong>vectors</strong> (<em>(3,3) float</em>) – Row vectors pointing along the
principal axes of inertia</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.radial_symmetry">
<code class="sig-prename descclassname">trimesh.inertia.</code><code class="sig-name descname">radial_symmetry</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.radial_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a mesh has rotational symmetry.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>symmetry</strong> (<em>None or str</em>) – None         No rotational symmetry
‘radial’     Symmetric around an axis
‘spherical’  Symmetric around a point</p></li>
<li><p><strong>axis</strong> (<em>None or (3,) float</em>) – Rotation axis or point</p></li>
<li><p><strong>section</strong> (<em>None or (3, 2) float</em>) – If radial symmetry provide vectors
to get cross section</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.sphere_inertia">
<code class="sig-prename descclassname">trimesh.inertia.</code><code class="sig-name descname">sphere_inertia</code><span class="sig-paren">(</span><em class="sig-param">mass</em>, <em class="sig-param">radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.sphere_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inertia tensor of a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mass</strong> (<em>float</em>) – Mass of sphere</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of sphere</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>inertia</strong> – Inertia tensor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.transform_inertia">
<code class="sig-prename descclassname">trimesh.inertia.</code><code class="sig-name descname">transform_inertia</code><span class="sig-paren">(</span><em class="sig-param">transform</em>, <em class="sig-param">inertia_tensor</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.transform_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an inertia tensor to a new frame.</p>
<p>More details in OCW PDF:
MIT16_07F09_Lec26.pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transform</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) or </em><em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Transformation matrix</p></li>
<li><p><strong>inertia_tensor</strong> (<em>(</em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Inertia tensor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transformed</strong> – Inertia tensor in new frame</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(3, 3) float</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.integrate">
<span id="trimesh-integrate-module"></span><h2>trimesh.integrate module<a class="headerlink" href="#module-trimesh.integrate" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integrate-py">
<h3>integrate.py<a class="headerlink" href="#integrate-py" title="Permalink to this headline">¶</a></h3>
<p>Utilities for integrating functions over meshes surfaces.</p>
<dl class="function">
<dt id="trimesh.integrate.substitute_barycentric">
<code class="sig-prename descclassname">trimesh.integrate.</code><code class="sig-name descname">substitute_barycentric</code><span class="sig-paren">(</span><em class="sig-param">function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.integrate.substitute_barycentric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="trimesh.integrate.symbolic_barycentric">
<code class="sig-prename descclassname">trimesh.integrate.</code><code class="sig-name descname">symbolic_barycentric</code><span class="sig-paren">(</span><em class="sig-param">function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.integrate.symbolic_barycentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolically integrate a function(x,y,z) across a triangle or mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<em>string</em><em> or </em><em>sympy expression</em>) – x, y, z will be replaced with a barycentric representation
and the the function is integrated across the triangle.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>evaluator</strong> (<em>numpy lambda function of result which takes a mesh</em>)</p></li>
<li><p><strong>expr</strong> (<em>sympy expression of result</em>)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: function = ‘1’</p>
<p>In [2]: integrator, expr = integrate_barycentric(function)</p>
<p>In [3]: integrator
Out[3]: &lt;__main__.evaluator instance at 0x7f66cd2a6200&gt;</p>
<p>In [4]: expr
Out[4]: 1/2</p>
<p>In [5]: result  = integrator(mesh)</p>
<p>In [6]: mesh.area
Out[6]: 34.641016151377542</p>
<p>In [7]: result.sum()
Out[7]: 34.641016151377542</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.intersections">
<span id="trimesh-intersections-module"></span><h2>trimesh.intersections module<a class="headerlink" href="#module-trimesh.intersections" title="Permalink to this headline">¶</a></h2>
<div class="section" id="intersections-py">
<h3>intersections.py<a class="headerlink" href="#intersections-py" title="Permalink to this headline">¶</a></h3>
<p>Primarily mesh-plane intersections (slicing).</p>
<dl class="function">
<dt id="trimesh.intersections.mesh_multiplane">
<code class="sig-prename descclassname">trimesh.intersections.</code><code class="sig-name descname">mesh_multiplane</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">plane_origin</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">heights</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.mesh_multiplane" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility function for slicing a mesh by multiple
parallel planes, which caches the dot product operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Geometry to be sliced by planes</p></li>
<li><p><strong>plane_normal</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Normal vector of plane</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on a plane</p></li>
<li><p><strong>heights</strong> (<em>(</em><em>m</em><em>,</em><em>) </em><em>float</em>) – Offset distances from plane to slice at</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>lines</strong> (<em>(m,) sequence of (n, 2, 2) float</em>) – Lines in space for m planes</p></li>
<li><p><strong>to_3D</strong> (<em>(m, 4, 4) float</em>) – Transform to move each section back to 3D</p></li>
<li><p><strong>face_index</strong> (<em>(m,) sequence of (n,) int</em>) – Indexes of mesh.faces for each segment</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.mesh_plane">
<code class="sig-prename descclassname">trimesh.intersections.</code><code class="sig-name descname">mesh_plane</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">plane_origin</em>, <em class="sig-param">return_faces=False</em>, <em class="sig-param">cached_dots=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.mesh_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a the intersections between a mesh and a plane,
returning a set of line segments on that plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – Source mesh to slice</p></li>
<li><p><strong>plane_normal</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Normal vector of plane to intersect with mesh</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on plane to intersect with mesh</p></li>
<li><p><strong>return_faces</strong> (<em>bool</em>) – If True return face index each line is from</p></li>
<li><p><strong>cached_dots</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – If an external function has stored dot
products pass them here to avoid recomputing</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>lines</strong> (<em>(m, 2, 3) float</em>) – List of 3D line segments in space</p></li>
<li><p><strong>face_index</strong> (<em>(m,) int</em>) – Index of mesh.faces for each line
Only returned if return_faces was True</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.plane_lines">
<code class="sig-prename descclassname">trimesh.intersections.</code><code class="sig-name descname">plane_lines</code><span class="sig-paren">(</span><em class="sig-param">plane_origin</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">endpoints</em>, <em class="sig-param">line_segments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.plane_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate plane-line intersections</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on plane</p></li>
<li><p><strong>plane_normal</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Plane normal vector</p></li>
<li><p><strong>endpoints</strong> (<em>(</em><em>2</em><em>, </em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points defining lines to be tested</p></li>
<li><p><strong>line_segments</strong> (<em>bool</em>) – If True, only returns intersections as valid if
vertices from endpoints are on different sides
of the plane.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>intersections</strong> (<em>(m, 3) float</em>) – Cartesian intersection points</p></li>
<li><p><strong>valid</strong> (<em>(n, 3) bool</em>) – Indicate whether a valid intersection exists
for each input line segment</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.planes_lines">
<code class="sig-prename descclassname">trimesh.intersections.</code><code class="sig-name descname">planes_lines</code><span class="sig-paren">(</span><em class="sig-param">plane_origins</em>, <em class="sig-param">plane_normals</em>, <em class="sig-param">line_origins</em>, <em class="sig-param">line_directions</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.planes_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Given one line per plane, find the intersection points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_origins</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Point on each plane</p></li>
<li><p><strong>plane_normals</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Normal vector of each plane</p></li>
<li><p><strong>line_origins</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Point at origin of each line</p></li>
<li><p><strong>line_directions</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Direction vector of each line</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>on_plane</strong> (<em>(n,3) float</em>) – Points on specified planes</p></li>
<li><p><strong>valid</strong> (<em>(n,) bool</em>) – Did plane intersect line or not</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.slice_faces_plane">
<code class="sig-prename descclassname">trimesh.intersections.</code><code class="sig-name descname">slice_faces_plane</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">faces</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">plane_origin</em>, <em class="sig-param">cached_dots=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.slice_faces_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a mesh (given as a set of faces and vertices) with a plane, returning a
new mesh (again as a set of faces and vertices) that is the
portion of the original mesh to the positive normal side of the plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertices of source mesh to slice</p></li>
<li><p><strong>faces</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>int</em>) – Faces of source mesh to slice</p></li>
<li><p><strong>plane_normal</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Normal vector of plane to intersect with mesh</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on plane to intersect with mesh</p></li>
<li><p><strong>cached_dots</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – If an external function has stored dot
products pass them here to avoid recomputing</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>new_vertices</strong> (<em>(n, 3) float</em>) – Vertices of sliced mesh</p></li>
<li><p><strong>new_faces</strong> (<em>(n, 3) int</em>) – Faces of sliced mesh</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.slice_mesh_plane">
<code class="sig-prename descclassname">trimesh.intersections.</code><code class="sig-name descname">slice_mesh_plane</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">plane_origin</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.slice_mesh_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a mesh with a plane, returning a new mesh that is the
portion of the original mesh to the positive normal side of the plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – Source mesh to slice</p></li>
<li><p><strong>plane_normal</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Normal vector of plane to intersect with mesh</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on plane to intersect with mesh</p></li>
<li><p><strong>cap</strong> (<em>bool</em>) – If True, cap the result with a triangulated polygon</p></li>
<li><p><strong>cached_dots</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – If an external function has stored dot
products pass them here to avoid recomputing</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>new_mesh</strong> – Sliced mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Trimesh object</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.interval">
<span id="trimesh-interval-module"></span><h2>trimesh.interval module<a class="headerlink" href="#module-trimesh.interval" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interval-py">
<h3>interval.py<a class="headerlink" href="#interval-py" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>Deal with 1D intervals which are defined by:</dt><dd><p>[start position, end position]</p>
</dd>
</dl>
<dl class="function">
<dt id="trimesh.interval.check">
<code class="sig-prename descclassname">trimesh.interval.</code><code class="sig-name descname">check</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">digits</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.interval.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input ranges, convert them to vector form,
and get a fixed precision integer version of them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>2</em><em>, </em><em>) or </em><em>(</em><em>2</em><em>, </em><em>n</em><em>) </em><em>float</em>) – Start and end of a 1D interval</p></li>
<li><p><strong>b</strong> (<em>(</em><em>2</em><em>, </em><em>) or </em><em>(</em><em>2</em><em>, </em><em>n</em><em>) </em><em>float</em>) – Start and end of a 1D interval</p></li>
<li><p><strong>digits</strong> (<em>int</em>) – How many digits to consider</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>a</strong> (<em>(2, n) float</em>) – Ranges as vector</p></li>
<li><p><strong>b</strong> (<em>(2, n) float</em>) – Ranges as vector</p></li>
<li><p><strong>a_int</strong> (<em>(2, n) int64</em>) – Ranges rounded to digits, as vector</p></li>
<li><p><strong>b_int</strong> (<em>(2, n) int64</em>) – Ranges rounded to digits, as vector</p></li>
<li><p><strong>is_1D</strong> (<em>bool</em>) – If True, input was single pair of ranges</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.interval.intersection">
<code class="sig-prename descclassname">trimesh.interval.</code><code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">digits=8</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.interval.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pair of ranges, merge them in to
one range if they overlap at all</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>2</em><em>, </em><em>) </em><em>float</em>) – Start and end of a 1D interval</p></li>
<li><p><strong>b</strong> (<em>(</em><em>2</em><em>, </em><em>) </em><em>float</em>) – Start and end of a 1D interval</p></li>
<li><p><strong>digits</strong> (<em>int</em>) – How many digits to consider</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>intersects</strong> (<em>bool or (n,) bool</em>) – Indicates if the ranges overlap at all</p></li>
<li><p><strong>new_range</strong> (<em>(2, ) or (2, 2) float</em>) – The unioned range from the two inputs,
or both of the original ranges if not overlapping</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.nsphere">
<span id="trimesh-nsphere-module"></span><h2>trimesh.nsphere module<a class="headerlink" href="#module-trimesh.nsphere" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nsphere-py">
<h3>nsphere.py<a class="headerlink" href="#nsphere-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for fitting and minimizing nspheres:
circles, spheres, hyperspheres, etc.</p>
<dl class="function">
<dt id="trimesh.nsphere.fit_nsphere">
<code class="sig-prename descclassname">trimesh.nsphere.</code><code class="sig-name descname">fit_nsphere</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">prior=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.fit_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an n-sphere to a set of points using least squares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Points in space</p></li>
<li><p><strong>prior</strong> (<em>(</em><em>d</em><em>,</em><em>) </em><em>float</em>) – Best guess for center of nsphere</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>center</strong> (<em>(d,) float</em>) – Location of center</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Mean radius across circle</p></li>
<li><p><strong>error</strong> (<em>float</em>) – Peak to peak value of deviation from mean radius</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.nsphere.is_nsphere">
<code class="sig-prename descclassname">trimesh.nsphere.</code><code class="sig-name descname">is_nsphere</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.is_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a list of points is an nsphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>dimension</em><em>) </em><em>float</em>) – Points in space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>check</strong> – True if input points are on an nsphere</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.nsphere.minimum_nsphere">
<code class="sig-prename descclassname">trimesh.nsphere.</code><code class="sig-name descname">minimum_nsphere</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.minimum_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum n- sphere for a mesh or a set of points.</p>
<p>Uses the fact that the minimum n- sphere will be centered at one of
the vertices of the furthest site voronoi diagram, which is n*log(n)
but should be pretty fast due to using the scipy/qhull implementations
of convex hulls and voronoi diagrams.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em><em> or </em><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Points or mesh to find minimum bounidng nsphere</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>center</strong> (<em>(d,) float</em>) – Center of fitted n- sphere</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of fitted n-sphere</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.parent">
<span id="trimesh-parent-module"></span><h2>trimesh.parent module<a class="headerlink" href="#module-trimesh.parent" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parent-py">
<h3>parent.py<a class="headerlink" href="#parent-py" title="Permalink to this headline">¶</a></h3>
<p>The base class for Trimesh, PointCloud, and Scene objects</p>
<dl class="class">
<dt id="trimesh.parent.Geometry">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.parent.</code><code class="sig-name descname">Geometry</code><a class="headerlink" href="#trimesh.parent.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Parent of geometry classes.</p>
<p>The <cite>Geometry</cite> object is the parent object of geometry classes, including:
Trimesh, PointCloud, and Scene objects.</p>
<p>By decorating a method with <cite>abc.abstractmethod</cite> it just means the objects
that inherit from <cite>Geometry</cite> MUST implement those methods.</p>
<dl class="method">
<dt id="trimesh.parent.Geometry.apply_scale">
<code class="sig-name descname">apply_scale</code><span class="sig-paren">(</span><em class="sig-param">scaling</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.apply_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the mesh equally on all axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scaling</strong> (<em>float</em>) – Scale factor to apply to the mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.apply_transform">
<em class="property">abstract </em><code class="sig-name descname">apply_transform</code><span class="sig-paren">(</span><em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.apply_translation">
<code class="sig-name descname">apply_translation</code><span class="sig-paren">(</span><em class="sig-param">translation</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.apply_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>translation</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Translation in XYZ</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.bounding_box">
<em class="property">property </em><code class="sig-name descname">bounding_box</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>An axis aligned bounding box for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>aabb</strong> – Box object with transform and extents defined
representing the axis aligned bounding box of the mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.primitives.Box" title="trimesh.primitives.Box">trimesh.primitives.Box</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.bounding_box_oriented">
<em class="property">property </em><code class="sig-name descname">bounding_box_oriented</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_box_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>An oriented bounding box for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>obb</strong> – Box object with transform and extents defined
representing the minimum volume oriented bounding box of the mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.primitives.Box" title="trimesh.primitives.Box">trimesh.primitives.Box</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.bounding_cylinder">
<em class="property">property </em><code class="sig-name descname">bounding_cylinder</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>A minimum volume bounding cylinder for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>mincyl</strong> – Cylinder primitive containing current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.primitives.Cylinder" title="trimesh.primitives.Cylinder">trimesh.primitives.Cylinder</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.bounding_primitive">
<em class="property">property </em><code class="sig-name descname">bounding_primitive</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum volume primitive (box, sphere, or cylinder) that
bounds the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bounding_primitive</strong> – Smallest primitive which bounds the mesh:
trimesh.primitives.Sphere
trimesh.primitives.Box
trimesh.primitives.Cylinder</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.bounding_sphere">
<em class="property">property </em><code class="sig-name descname">bounding_sphere</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>A minimum volume bounding sphere for the current mesh.</p>
<p>Note that the Sphere primitive returned has an unpadded, exact
sphere_radius so while the distance of every vertex of the current
mesh from sphere_center will be less than sphere_radius, the faceted
sphere primitive may not contain every vertex</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>minball</strong> – Sphere primitive containing current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.primitives.Sphere" title="trimesh.primitives.Sphere">trimesh.primitives.Sphere</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.bounds">
<em class="property">abstract property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#trimesh.parent.Geometry.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.copy">
<em class="property">abstract </em><code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.extents">
<em class="property">abstract property </em><code class="sig-name descname">extents</code><a class="headerlink" href="#trimesh.parent.Geometry.extents" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.is_empty">
<em class="property">abstract </em><code class="sig-name descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.is_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.show">
<em class="property">abstract </em><code class="sig-name descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.show" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.permutate">
<span id="trimesh-permutate-module"></span><h2>trimesh.permutate module<a class="headerlink" href="#module-trimesh.permutate" title="Permalink to this headline">¶</a></h2>
<div class="section" id="permutate-py">
<h3>permutate.py<a class="headerlink" href="#permutate-py" title="Permalink to this headline">¶</a></h3>
<p>Randomly deform meshes in different ways.</p>
<dl class="class">
<dt id="trimesh.permutate.Permutator">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.permutate.</code><code class="sig-name descname">Permutator</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="trimesh.permutate.Permutator.noise">
<code class="sig-name descname">noise</code><span class="sig-paren">(</span><em class="sig-param">magnitude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add gaussian noise to every vertex of a mesh, making
no effort to maintain topology or sanity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Input geometry, will not be altered</p></li>
<li><p><strong>magnitude</strong> (<em>float</em>) – What is the maximum distance per axis we can displace a vertex.
If None, value defaults to (mesh.scale / 100.0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutated</strong> – Input mesh with noise applied</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.permutate.Permutator.tessellation">
<code class="sig-name descname">tessellation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.tessellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide each face of a mesh into three faces with the new vertex
randomly placed inside the old face.</p>
<p>This produces a mesh with exactly the same surface area and volume
but with different tessellation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Input geometry</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutated</strong> – Mesh with remeshed facets</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.permutate.Permutator.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">translation_scale=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a permutated variant of a mesh by randomly reording faces
and rotatating + translating a mesh by a random matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Mesh, will not be altered by this function</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutated</strong> – Mesh with same faces as input mesh but reordered
and rigidly transformed in space.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.noise">
<code class="sig-prename descclassname">trimesh.permutate.</code><code class="sig-name descname">noise</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">magnitude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add gaussian noise to every vertex of a mesh, making
no effort to maintain topology or sanity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Input geometry, will not be altered</p></li>
<li><p><strong>magnitude</strong> (<em>float</em>) – What is the maximum distance per axis we can displace a vertex.
If None, value defaults to (mesh.scale / 100.0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutated</strong> – Input mesh with noise applied</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.tessellation">
<code class="sig-prename descclassname">trimesh.permutate.</code><code class="sig-name descname">tessellation</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.tessellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide each face of a mesh into three faces with the new vertex
randomly placed inside the old face.</p>
<p>This produces a mesh with exactly the same surface area and volume
but with different tessellation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Input geometry</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutated</strong> – Mesh with remeshed facets</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.transform">
<code class="sig-prename descclassname">trimesh.permutate.</code><code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">translation_scale=1000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a permutated variant of a mesh by randomly reording faces
and rotatating + translating a mesh by a random matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Mesh, will not be altered by this function</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>permutated</strong> – Mesh with same faces as input mesh but reordered
and rigidly transformed in space.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.points">
<span id="trimesh-points-module"></span><h2>trimesh.points module<a class="headerlink" href="#module-trimesh.points" title="Permalink to this headline">¶</a></h2>
<div class="section" id="points-py">
<h3>points.py<a class="headerlink" href="#points-py" title="Permalink to this headline">¶</a></h3>
<p>Functions dealing with (n, d) points.</p>
<dl class="class">
<dt id="trimesh.points.PointCloud">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">PointCloud</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">colors=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<p>Hold 3D points in an object which can be visualized
in a scene.</p>
<dl class="method">
<dt id="trimesh.points.PointCloud.apply_transform">
<code class="sig-name descname">apply_transform</code><span class="sig-paren">(</span><em class="sig-param">transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a homogeneous transformation to the PointCloud
object in- place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transform</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Homogeneous transformation to apply to PointCloud</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.bounds">
<em class="property">property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#trimesh.points.PointCloud.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bounds</strong> – Miniumum, Maximum verteex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.centroid">
<em class="property">property </em><code class="sig-name descname">centroid</code><a class="headerlink" href="#trimesh.points.PointCloud.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean vertex position</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>centroid</strong> – Mean vertex position</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.colors">
<em class="property">property </em><code class="sig-name descname">colors</code><a class="headerlink" href="#trimesh.points.PointCloud.colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Stored per- point color</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>colors</strong> – Per- point RGBA color</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), 4) np.uint8</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.convex_hull">
<em class="property">property </em><code class="sig-name descname">convex_hull</code><a class="headerlink" href="#trimesh.points.PointCloud.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>A convex hull of every point.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>convex_hull</strong> – A watertight mesh of the hull of the points</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely get a copy of the current point cloud.</p>
<p>Copied objects will have emptied caches to avoid memory
issues and so may be slow on initial operations until
caches are regenerated.</p>
<p>Current object will <em>not</em> have its cache cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>copied</strong> – Copy of current point cloud</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.PointCloud" title="trimesh.PointCloud">trimesh.PointCloud</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.extents">
<em class="property">property </em><code class="sig-name descname">extents</code><a class="headerlink" href="#trimesh.points.PointCloud.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the axis aligned bounds</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>extents</strong> – Edge length of axis aligned bounding box</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.is_empty">
<em class="property">property </em><code class="sig-name descname">is_empty</code><a class="headerlink" href="#trimesh.points.PointCloud.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Are there any vertices defined or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>empty</strong> – True if no vertices defined</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.md5">
<code class="sig-name descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an MD5 hash of the current vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>md5</strong> – Hash of self.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.merge_vertices">
<code class="sig-name descname">merge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge vertices closer than tol.merge (default: 1e-8)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.scene">
<code class="sig-name descname">scene</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>A scene containing just the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scene</strong> – Scene object containing this PointCloud</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene">trimesh.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#trimesh.points.PointCloud.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of the pointcloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>shape</strong> – Shape of vertex array</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a viewer window displaying the current PointCloud</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.vertices">
<em class="property">property </em><code class="sig-name descname">vertices</code><a class="headerlink" href="#trimesh.points.PointCloud.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertices of the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertices</strong> – Points in the PointCloud</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.points.k_means">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">k_means</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">k</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.k_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Find k centroids that attempt to minimize the k- means problem:
<a class="reference external" href="https://en.wikipedia.org/wiki/Metric_k-center">https://en.wikipedia.org/wiki/Metric_k-center</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Points in a space</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Number of centroids to compute</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – Passed directly to scipy.cluster.vq.kmeans</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>centroids</strong> (<em>(k, d) float</em>) – Points in some space</p></li>
<li><p><strong>labels</strong> (<em>(n) int</em>) – Indexes for which points belong to which centroid</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.major_axis">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">major_axis</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.major_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an approximate vector representing the major axis of points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>dimension</em><em>) </em><em>float</em><em>, </em><em>points in space</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>axis</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(dimension,) float, vector along approximate major axis</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.plane_fit">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">plane_fit</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.plane_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, find an origin and normal using SVD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Points in 3D space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>C</strong> (<em>(3,) float</em>) – Point on the plane</p></li>
<li><p><strong>N</strong> (<em>(3,) float</em>) – Normal vector of plane</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.plot_points">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">plot_points</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.plot_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot an (n,3) list of points using matplotlib</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points in space</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If False, will not show until plt.show() is called</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.point_plane_distance">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">point_plane_distance</code><span class="sig-paren">(</span><em class="sig-param">points, plane_normal, plane_origin=[0.0, 0.0, 0.0]</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.point_plane_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum perpendicular distance of a point to a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em><em>, </em><em>points in space</em>) – </p></li>
<li><p><strong>plane_normal</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em><em>, </em><em>normal vector</em>) – </p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em><em>, </em><em>plane origin in space</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>distances</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float, distance from point to plane</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.project_to_plane">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">project_to_plane</code><span class="sig-paren">(</span><em class="sig-param">points, plane_normal=[0, 0, 1], plane_origin=[0, 0, 0], transform=None, return_transform=False, return_planar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.project_to_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects a set of (n,3) points onto a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>array of points</em>) – </p></li>
<li><p><strong>plane_normal</strong> – </p></li>
<li><p><strong>plane_origin</strong> – </p></li>
<li><p><strong>transform</strong> (<em>None</em><em> or </em><em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>matrix. If specified</em><em>, </em><em>normal/origin are ignored</em>) – </p></li>
<li><p><strong>return_transform</strong> (<em>bool</em><em>, </em><em>if true returns the</em><em> (</em><em>4</em><em>,</em><em>4</em><em>) </em><em>matrix used to project points</em>) – onto a plane</p></li>
<li><p><strong>return_planar</strong> (<em>bool</em><em>, </em><em>if True</em><em>, </em><em>returns</em><em> (</em><em>n</em><em>,</em><em>2</em><em>) </em><em>points. If False</em><em>, </em><em>returns</em>) – (n,3), where the Z column consists of zeros</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.radial_sort">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">radial_sort</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">origin</em>, <em class="sig-param">normal</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.radial_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts a set of points radially (by angle) around an
origin/normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>points in space</em>) – </p></li>
<li><p><strong>origin</strong> (<em>(</em><em>3</em><em>,</em><em>)  </em><em>float</em><em>, </em><em>origin to sort around</em>) – </p></li>
<li><p><strong>normal</strong> (<em>(</em><em>3</em><em>,</em><em>)  </em><em>float</em><em>, </em><em>vector to sort around</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ordered</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,3) flot, re- ordered points in space</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.remove_close">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">remove_close</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.remove_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an (n, m) set of points where n=(2|3) return a list of points
where no point is closer than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>dimension</em><em>) </em><em>float</em>) – Points in space</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Minimum radius between result points</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>culled</strong> (<em>(m, dimension) float</em>) – Points in space</p></li>
<li><p><strong>mask</strong> (<em>(n,) bool</em>) – Which points from the original set were returned</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.tsp">
<code class="sig-prename descclassname">trimesh.points.</code><code class="sig-name descname">tsp</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.tsp" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an ordering of points where each is visited and
the next point is the closest in euclidean distance,
and if there are multiple points with equal distance
go to an arbitrary one.</p>
<p>Assumes every point is visitable from every other point,
i.e. the travelling salesman problem on a fully connected
graph. It is not a MINIMUM traversal; rather it is a
“not totally goofy traversal, quickly.” On random points
this traversal is often ~20x shorter than random ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>dimension</em><em>) </em><em>float</em>) – ND points in space</p></li>
<li><p><strong>start</strong> (<em>int</em>) – The index of points we should start at</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>traversal</strong> (<em>(n,) int</em>) – Ordered traversal visiting every point</p></li>
<li><p><strong>distances</strong> (<em>(n - 1,) float</em>) – The euclidean distance between points in traversal</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.poses">
<span id="trimesh-poses-module"></span><h2>trimesh.poses module<a class="headerlink" href="#module-trimesh.poses" title="Permalink to this headline">¶</a></h2>
<div class="section" id="poses-py">
<h3>poses.py<a class="headerlink" href="#poses-py" title="Permalink to this headline">¶</a></h3>
<p>Find stable orientations of meshes.</p>
<dl class="function">
<dt id="trimesh.poses.compute_stable_poses">
<code class="sig-prename descclassname">trimesh.poses.</code><code class="sig-name descname">compute_stable_poses</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">center_mass=None</em>, <em class="sig-param">sigma=0.0</em>, <em class="sig-param">n_samples=1</em>, <em class="sig-param">threshold=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.poses.compute_stable_poses" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p>
<p>This method samples the location of the center of mass from a multivariate
gaussian with the mean at the center of mass, and a covariance
equal to and identity matrix times sigma, over n_samples.</p>
<p>For each sample, it computes the stable resting poses of the mesh on a
a planar workspace and evaluates the probabilities of landing in
each pose if the object is dropped onto the table randomly.</p>
<p>This method returns the 4x4 homogeneous transform matrices that place
the shape against the planar surface with the z-axis pointing upwards
and a list of the probabilities for each pose.</p>
<p>The transforms and probabilties that are returned are sorted, with the
most probable pose first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – The target mesh</p></li>
<li><p><strong>com</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Rhe object center of mass. If None, this method
assumes uniform density and watertightness and
computes a center of mass explicitly</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – Rhe covariance for the multivariate gaussian used
to sample center of mass locations</p></li>
<li><p><strong>n_samples</strong> (<em>int</em>) – The number of samples of the center of mass location</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The probability value at which to threshold
returned stable poses</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>transforms</strong> (<em>(n, 4, 4) float</em>) – The homogeneous matrices that transform the
object to rest in a stable pose, with the
new z-axis pointing upwards from the table
and the object just touching the table.</p></li>
<li><p><strong>probs</strong> (<em>(n,) float</em>) – Probability in (0, 1) for each pose</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.primitives">
<span id="trimesh-primitives-module"></span><h2>trimesh.primitives module<a class="headerlink" href="#module-trimesh.primitives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="primitives-py">
<h3>primitives.py<a class="headerlink" href="#primitives-py" title="Permalink to this headline">¶</a></h3>
<p>Subclasses of Trimesh objects that are parameterized as primitives.</p>
<p>Useful because you can move boxes and spheres around, and then use
trimesh operations on them at any point.</p>
<dl class="class">
<dt id="trimesh.primitives.Box">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.primitives.</code><code class="sig-name descname">Box</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="method">
<dt id="trimesh.primitives.Box.is_oriented">
<em class="property">property </em><code class="sig-name descname">is_oriented</code><a class="headerlink" href="#trimesh.primitives.Box.is_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether or not the current box is rotated at all.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Box.sample_grid">
<code class="sig-name descname">sample_grid</code><span class="sig-paren">(</span><em class="sig-param">count=None</em>, <em class="sig-param">step=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box.sample_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 3D grid which is contained by the box.
Samples are either ‘step’ distance apart, or there are
‘count’ samples per box side.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>count</strong> (<em>int</em><em> or </em><em>(</em><em>3</em><em>,</em><em>) </em><em>int</em>) – If specified samples are spaced with np.linspace</p></li>
<li><p><strong>step</strong> (<em>float</em><em> or </em><em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – If specified samples are spaced with np.arange</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grid</strong> – Points inside the box</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Box.sample_volume">
<code class="sig-name descname">sample_volume</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box.sample_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples from inside the volume of the box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>count</strong> (<em>int</em>) – Number of samples to return</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>samples</strong> – Points inside the volume</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(count, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Box.volume">
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#trimesh.primitives.Box.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the box Primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>volume</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float, volume of box</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Capsule">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.primitives.</code><code class="sig-name descname">Capsule</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="method">
<dt id="trimesh.primitives.Capsule.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#trimesh.primitives.Capsule.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>The direction of the capsule’s axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>axis</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float, vector along the cylinder axis</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Cylinder">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.primitives.</code><code class="sig-name descname">Cylinder</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="method">
<dt id="trimesh.primitives.Cylinder.buffer">
<code class="sig-name descname">buffer</code><span class="sig-paren">(</span><em class="sig-param">distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Cylinder.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cylinder primitive which covers the source cylinder
by distance: radius is inflated by distance, height by twice
the distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distance</strong> (<em>float</em>) – Distance to inflate cylinder radius and height</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>buffered</strong> – Cylinder primitive inflated by distance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.primitives.Cylinder" title="trimesh.primitives.Cylinder">Cylinder</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Cylinder.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#trimesh.primitives.Cylinder.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>The direction of the cylinder’s axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>axis</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float, vector along the cylinder axis</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Cylinder.moment_inertia">
<em class="property">property </em><code class="sig-name descname">moment_inertia</code><a class="headerlink" href="#trimesh.primitives.Cylinder.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic inertia tensor of the cylinder primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tensor</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,3) float, 3D inertia tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Cylinder.segment">
<em class="property">property </em><code class="sig-name descname">segment</code><a class="headerlink" href="#trimesh.primitives.Cylinder.segment" title="Permalink to this definition">¶</a></dt>
<dd><p>A line segment which if inflated by cylinder radius
would represent the cylinder primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>segment</strong> – Points representing a single line segment</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Cylinder.volume">
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#trimesh.primitives.Cylinder.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic volume of the cylinder primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>volume</strong> – Volume of the cylinder</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Extrusion">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.primitives.</code><code class="sig-name descname">Extrusion</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="method">
<dt id="trimesh.primitives.Extrusion.area">
<em class="property">property </em><code class="sig-name descname">area</code><a class="headerlink" href="#trimesh.primitives.Extrusion.area" title="Permalink to this definition">¶</a></dt>
<dd><p>The surface area of the primitive extrusion.</p>
<p>Calculated from polygon and height to avoid mesh creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float, surface area of 3D extrusion</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.buffer">
<code class="sig-name descname">buffer</code><span class="sig-paren">(</span><em class="sig-param">distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Extrusion object which is expanded in profile and
in height by a specified distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>buffered</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Extrusion object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.direction">
<em class="property">property </em><code class="sig-name descname">direction</code><a class="headerlink" href="#trimesh.primitives.Extrusion.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on the extrudes transform, what is the vector along
which the polygon will be extruded</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>direction</strong> – identity matrix this will be [0.0, 0.0, 1.0]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float vector. If self.primitive.transform is an</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.slide">
<code class="sig-name descname">slide</code><span class="sig-paren">(</span><em class="sig-param">distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion.slide" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the transform of the current extrusion to slide it
along its extrude_direction vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distance</strong> (<em>float</em><em>, </em><em>distance along self.extrude_direction to move</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.volume">
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#trimesh.primitives.Extrusion.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>The volume of the primitive extrusion.</p>
<p>Calculated from polygon and height to avoid mesh creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>volume</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float, volume of 3D extrusion</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Sphere">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.primitives.</code><code class="sig-name descname">Sphere</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="method">
<dt id="trimesh.primitives.Sphere.apply_transform">
<code class="sig-name descname">apply_transform</code><span class="sig-paren">(</span><em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Sphere.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transform to the sphere primitive</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em><em>, </em><em>homogeneous transformation</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Sphere.area">
<em class="property">property </em><code class="sig-name descname">area</code><a class="headerlink" href="#trimesh.primitives.Sphere.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface area of the current sphere primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float, surface area of the sphere Primitive</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Sphere.bounding_box_oriented">
<em class="property">property </em><code class="sig-name descname">bounding_box_oriented</code><a class="headerlink" href="#trimesh.primitives.Sphere.bounding_box_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>An oriented bounding box for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>obb</strong> – Box object with transform and extents defined
representing the minimum volume oriented bounding box of the mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.primitives.Box" title="trimesh.primitives.Box">trimesh.primitives.Box</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Sphere.bounds">
<em class="property">property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#trimesh.primitives.Sphere.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the faces of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bounds</strong> – Bounding box with [min, max] coordinates</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Sphere.moment_inertia">
<em class="property">property </em><code class="sig-name descname">moment_inertia</code><a class="headerlink" href="#trimesh.primitives.Sphere.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic inertia tensor of the sphere primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tensor</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,3) float, 3D inertia tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Sphere.volume">
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#trimesh.primitives.Sphere.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the current sphere primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>volume</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float, volume of the sphere Primitive</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.proximity">
<span id="trimesh-proximity-module"></span><h2>trimesh.proximity module<a class="headerlink" href="#module-trimesh.proximity" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proximity-py">
<h3>proximity.py<a class="headerlink" href="#proximity-py" title="Permalink to this headline">¶</a></h3>
<p>Query mesh- point proximity.</p>
<dl class="class">
<dt id="trimesh.proximity.ProximityQuery">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">ProximityQuery</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Proximity queries for the current mesh.</p>
<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.on_surface">
<code class="sig-name descname">on_surface</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.on_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Given list of points, for each point find the closest point
on any triangle of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>m</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>points in space</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>closest</strong> (<em>(m,3) float, closest point on triangles for each point</em>)</p></li>
<li><p><strong>distance</strong> (<em>(m,)  float, distance</em>)</p></li>
<li><p><strong>triangle_id</strong> (<em>(m,)  int, index of closest triangle for each point</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.signed_distance">
<code class="sig-name descname">signed_distance</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.signed_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the signed distance from a mesh to a list of points.</p>
<ul class="simple">
<li><p>Points OUTSIDE the mesh will have NEGATIVE distance</p></li>
<li><p>Points within tol.merge of the surface will have POSITIVE distance</p></li>
<li><p>Points INSIDE the mesh will have POSITIVE distance</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>signed_distance</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,3) float, signed distance from point to mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.vertex">
<code class="sig-name descname">vertex</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, return the closest vertex index to each point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>distance</strong> (<em>(n,) float, distance from source point to vertex</em>)</p></li>
<li><p><strong>vertex_id</strong> (<em>(n,) int, index of mesh.vertices which is closest</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.closest_point">
<code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">closest_point</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh and a list of points, find the closest point on any triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p></li>
<li><p><strong>points</strong> (<em>(</em><em>m</em><em>,</em><em>3</em><em>)   </em><em>float</em><em>, </em><em>points in space</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>closest</strong> (<em>(m,3) float, closest point on triangles for each point</em>)</p></li>
<li><p><strong>distance</strong> (<em>(m,)  float, distance</em>)</p></li>
<li><p><strong>triangle_id</strong> (<em>(m,)  int, index of triangle containing closest point</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.closest_point_naive">
<code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">closest_point_naive</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.closest_point_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh and a list of points find the closest point
on any triangle.</p>
<p>Does this by constructing a very large intermediate array and
comparing every point to every triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a>) – Takes mesh to have same interfaces as <cite>closest_point</cite></p></li>
<li><p><strong>points</strong> (<em>(</em><em>m</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points in space</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>closest</strong> (<em>(m, 3) float</em>) – Closest point on triangles for each point</p></li>
<li><p><strong>distance</strong> (<em>(m,) float</em>) – Distances between point and triangle</p></li>
<li><p><strong>triangle_id</strong> (<em>(m,) int</em>) – Index of triangle containing closest point</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.longest_ray">
<code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">longest_ray</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em>, <em class="sig-param">directions</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.longest_ray" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the lengths of the longest rays which do not intersect the mesh
cast from a list of points in the provided directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
<li><p><strong>directions</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>directions of rays</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>signed_distance</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float, length of rays</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.max_tangent_sphere">
<code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">max_tangent_sphere</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em>, <em class="sig-param">inwards=True</em>, <em class="sig-param">normals=None</em>, <em class="sig-param">threshold=1e-06</em>, <em class="sig-param">max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.max_tangent_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the center and radius of the sphere which is tangent to
the mesh at the given point and at least one more point with no
non-tangential intersections with the mesh.</p>
<p>Masatomo Inui, Nobuyuki Umezu &amp; Ryohei Shimane (2016)
Shrinking sphere:
A parallel algorithm for computing the thickness of 3D objects,
Computer-Aided Design and Applications, 13:2, 199-207,
DOI: 10.1080/16864360.2015.1084186</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
<li><p><strong>inwards</strong> (<em>bool</em><em>, </em><em>whether to have the sphere inside</em><em> or </em><em>outside the mesh</em>) – </p></li>
<li><p><strong>normals</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>normals of the mesh at the given points</em>) – None, compute this automatically.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>centers</strong> (<em>(n,3) float, centers of spheres</em>)</p></li>
<li><p><strong>radii</strong> (<em>(n,) float, radii of spheres</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.nearby_faces">
<code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">nearby_faces</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.nearby_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point find nearby faces relatively quickly.</p>
<p>The closest point on the mesh to the queried point is guaranteed to be
on one of the faces listed.</p>
<p>Does this by finding the nearest vertex on the mesh to each point, and
then returns all the faces that intersect the axis aligned bounding box
centered at the queried point and extending to the nearest vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p></li>
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em> , </em><em>points in space</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>candidates</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(points,) int, sequence of indexes for mesh.faces</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.signed_distance">
<code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">signed_distance</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.signed_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the signed distance from a mesh to a list of points.</p>
<ul class="simple">
<li><p>Points OUTSIDE the mesh will have NEGATIVE distance</p></li>
<li><p>Points within tol.merge of the surface will have POSITIVE distance</p></li>
<li><p>Points INSIDE the mesh will have POSITIVE distance</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p></li>
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>signed_distance</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,3) float, signed distance from point to mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.thickness">
<code class="sig-prename descclassname">trimesh.proximity.</code><code class="sig-name descname">thickness</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">points</em>, <em class="sig-param">exterior=False</em>, <em class="sig-param">normals=None</em>, <em class="sig-param">method='max_sphere'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the thickness of the mesh at the given points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>list of points in space</em>) – </p></li>
<li><p><strong>exterior</strong> (<em>bool</em><em>, </em><em>whether to compute the exterior thickness</em>) – (a.k.a. reach)</p></li>
<li><p><strong>normals</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em><em>, </em><em>normals of the mesh at the given points</em>) – None, compute this automatically.</p></li>
<li><p><strong>method</strong> (<em>string</em><em>, </em><em>one of 'max_sphere'</em><em> or </em><em>'ray'</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>thickness</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float, thickness</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.registration">
<span id="trimesh-registration-module"></span><h2>trimesh.registration module<a class="headerlink" href="#module-trimesh.registration" title="Permalink to this headline">¶</a></h2>
<div class="section" id="registration-py">
<h3>registration.py<a class="headerlink" href="#registration-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for registering (aligning) point clouds with meshes.</p>
<dl class="function">
<dt id="trimesh.registration.icp">
<code class="sig-prename descclassname">trimesh.registration.</code><code class="sig-name descname">icp</code><span class="sig-paren">(</span><em class="sig-param">a, b, initial=array([[1., 0., 0., 0.],        [0., 1., 0., 0.],        [0., 0., 1., 0.],        [0., 0., 0., 1.]]), threshold=1e-05, max_iterations=20, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.icp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the iterative closest point algorithm to align a point cloud with
another point cloud or mesh. Will only produce reasonable results if the
initial transformation is roughly correct. Initial transformation can be
found by applying Procrustes’ analysis to a suitable set of landmark
points (often picked manually).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – List of points in space.</p></li>
<li><p><strong>b</strong> (<em>(</em><em>m</em><em>,</em><em>3</em><em>) </em><em>float</em><em> or </em><a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a>) – List of points in space or mesh.</p></li>
<li><p><strong>initial</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – Initial transformation.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Stop when change in cost is less than threshold</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em>) – Maximum number of iterations</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – Args to pass to procrustes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matrix</strong> (<em>(4,4) float</em>) – The transformation matrix sending a to b</p></li>
<li><p><strong>transformed</strong> (<em>(n,3) float</em>) – The image of a under the transformation</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – The cost of the transformation</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.registration.mesh_other">
<code class="sig-prename descclassname">trimesh.registration.</code><code class="sig-name descname">mesh_other</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">other</em>, <em class="sig-param">samples=500</em>, <em class="sig-param">scale=False</em>, <em class="sig-param">icp_first=10</em>, <em class="sig-param">icp_final=50</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.mesh_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a mesh with another mesh or a PointCloud using
the principal axes of inertia as a starting point which
is refined by iterative closest point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>trimesh.Trimesh object</em>) – Mesh to align with other</p></li>
<li><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em> or </em><em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Mesh or points in space</p></li>
<li><p><strong>samples</strong> (<em>int</em>) – Number of samples from mesh surface to align</p></li>
<li><p><strong>scale</strong> (<em>bool</em>) – Allow scaling in transform</p></li>
<li><p><strong>icp_first</strong> (<em>int</em>) – How many ICP iterations for the 9 possible
combinations of sign flippage</p></li>
<li><p><strong>icp_final</strong> (<em>int</em>) – How many ICP iterations for the closest
candidate from the wider search</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mesh_to_other</strong> (<em>(4, 4) float</em>) – Transform to align mesh to the other object</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Average squared distance per point</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.registration.procrustes">
<code class="sig-prename descclassname">trimesh.registration.</code><code class="sig-name descname">procrustes</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">reflection=True</em>, <em class="sig-param">translation=True</em>, <em class="sig-param">scale=True</em>, <em class="sig-param">return_cost=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.procrustes" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Procrustes’ analysis subject to constraints. Finds the
transformation T mapping a to b which minimizes the square sum
distances between Ta and b, also called the cost.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – List of points in space</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – List of points in space</p></li>
<li><p><strong>reflection</strong> (<em>bool</em>) – If the transformation is allowed reflections</p></li>
<li><p><strong>translation</strong> (<em>bool</em>) – If the transformation is allowed translations</p></li>
<li><p><strong>scale</strong> (<em>bool</em>) – If the transformation is allowed scaling</p></li>
<li><p><strong>return_cost</strong> (<em>bool</em>) – Whether to return the cost and transformed a as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>matrix</strong> (<em>(4,4) float</em>) – The transformation matrix sending a to b</p></li>
<li><p><strong>transformed</strong> (<em>(n,3) float</em>) – The image of a under the transformation</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – The cost of the transformation</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.remesh">
<span id="trimesh-remesh-module"></span><h2>trimesh.remesh module<a class="headerlink" href="#module-trimesh.remesh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="remesh-py">
<h3>remesh.py<a class="headerlink" href="#remesh-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with re- triangulation of existing meshes.</p>
<dl class="function">
<dt id="trimesh.remesh.subdivide">
<code class="sig-prename descclassname">trimesh.remesh.</code><code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">faces</em>, <em class="sig-param">face_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.remesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh into smaller triangles.</p>
<p>Note that if <cite>face_index</cite> is passed, only those faces will
be subdivided and their neighbors won’t be modified making
the mesh no longer “watertight.”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertices in space</p></li>
<li><p><strong>faces</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>int</em>) – Indexes of vertices which make up triangular faces</p></li>
<li><p><strong>face_index</strong> (<em>faces to subdivide.</em>) – if None: all faces of mesh will be subdivided
if (n,) int array of indices: only specified faces</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>new_vertices</strong> (<em>(n, 3) float</em>) – Vertices in space</p></li>
<li><p><strong>new_faces</strong> (<em>(n, 3) int</em>) – Remeshed faces</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.remesh.subdivide_to_size">
<code class="sig-prename descclassname">trimesh.remesh.</code><code class="sig-name descname">subdivide_to_size</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">faces</em>, <em class="sig-param">max_edge</em>, <em class="sig-param">max_iter=10</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.remesh.subdivide_to_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh until every edge is shorter than a
specified length.</p>
<p>Will return a triangle soup, not a nicely structured mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertices in space</p></li>
<li><p><strong>faces</strong> (<em>(</em><em>m</em><em>, </em><em>3</em><em>) </em><em>int</em>) – Indices of vertices which make up triangles</p></li>
<li><p><strong>max_edge</strong> (<em>float</em>) – Maximum length of any edge in the result</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – The maximum number of times to run subdivision</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vertices</strong> (<em>(j, 3) float</em>) – Vertices in space</p></li>
<li><p><strong>faces</strong> (<em>(q, 3) int</em>) – Indices of vertices</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.rendering">
<span id="trimesh-rendering-module"></span><h2>trimesh.rendering module<a class="headerlink" href="#module-trimesh.rendering" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rendering-py">
<h3>rendering.py<a class="headerlink" href="#rendering-py" title="Permalink to this headline">¶</a></h3>
<p>Functions to convert trimesh objects to pyglet/opengl objects.</p>
<dl class="function">
<dt id="trimesh.rendering.colors_to_gl">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">colors_to_gl</code><span class="sig-paren">(</span><em class="sig-param">colors</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.colors_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of colors (or None) return a GL-acceptable list of colors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>colors</strong> (<em>(</em><em>count</em><em>, </em><em>(</em><em>3</em><em> or </em><em>4</em><em>)</em><em>) </em><em>float</em>) – Input colors as an array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>colors_type</strong> (<em>str</em>) – Color type</p></li>
<li><p><strong>colors_gl</strong> (<em>(count,) list</em>) – Colors to pass to pyglet</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.convert_to_vertexlist">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">convert_to_vertexlist</code><span class="sig-paren">(</span><em class="sig-param">geometry</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.convert_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to convert various geometry objects to the constructor
args for a pyglet indexed vertex list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a><em>, </em><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path2D" title="trimesh.path.path.Path2D"><em>Path2D</em></a><em>, </em><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path3D" title="trimesh.path.path.Path3D"><em>Path3D</em></a><em>, </em><em>(</em><em>n</em><em>,</em><em>2</em><em>) </em><em>float</em><em>, </em><em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Object to render</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>args</strong> – Args to be passed to pyglet indexed vertex list
constructor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.light_to_gl">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">light_to_gl</code><span class="sig-paren">(</span><em class="sig-param">light</em>, <em class="sig-param">transform</em>, <em class="sig-param">lightN</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.light_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert trimesh.scene.lighting.Light objects into
args for gl.glLightFv calls</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>light</strong> (<a class="reference internal" href="trimesh.scene.html#trimesh.scene.lighting.Light" title="trimesh.scene.lighting.Light"><em>trimesh.scene.lighting.Light</em></a>) – Light object to be converted to GL</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Transformation matrix of light</p></li>
<li><p><strong>lightN</strong> (<em>int</em>) – Result of gl.GL_LIGHT0, gl.GL_LIGHT1, etc</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>multiarg</strong> – List of args to pass to gl.glLightFv eg:
[gl.glLightfb(<a href="#id19"><span class="problematic" id="id20">*</span></a>a) for a in multiarg]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[tuple]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.material_to_texture">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">material_to_texture</code><span class="sig-paren">(</span><em class="sig-param">material</em>, <em class="sig-param">upsize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.material_to_texture" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a trimesh.visual.texture.Material object into
a pyglet-compatible texture object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>material</strong> (<em>trimesh.visual.texture.Material</em>) – Material to be converted</p></li>
<li><p><strong>upsize</strong> (<em>bool</em>) – If True, will upscale textures to their nearest power
of two resolution to avoid weirdness</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>texture</strong> – Texture loaded into pyglet form</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pyglet.image.Texture</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.matrix_to_gl">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">matrix_to_gl</code><span class="sig-paren">(</span><em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.matrix_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a numpy row-major homogeneous transformation matrix
to a flat column-major GLfloat transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – Row-major homogeneous transform</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>glmatrix</strong> – Transform in pyglet format</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(16,) gl.GLfloat</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.mesh_to_vertexlist">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">mesh_to_vertexlist</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">group=None</em>, <em class="sig-param">smooth=True</em>, <em class="sig-param">smooth_threshold=60000</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.mesh_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Trimesh object to arguments for an
indexed vertex list constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Mesh to be rendered</p></li>
<li><p><strong>group</strong> (<em>str</em>) – Rendering group for the vertex list</p></li>
<li><p><strong>smooth</strong> (<em>bool</em>) – Should we try to smooth shade the mesh</p></li>
<li><p><strong>smooth_threshold</strong> (<em>int</em>) – Maximum number of faces to smooth shade</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>args</strong> – Args for vertex list constructor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(7,) tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.path_to_vertexlist">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">path_to_vertexlist</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">group=None</em>, <em class="sig-param">colors=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.path_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Path3D object to arguments for an
indexed vertex list constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>trimesh.path.Path3D object</em>) – Mesh to be rendered</p></li>
<li><p><strong>group</strong> (<em>str</em>) – Rendering group for the vertex list</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>args</strong> – Args for vertex list constructor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(7,) tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.points_to_vertexlist">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">points_to_vertexlist</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">colors=None</em>, <em class="sig-param">group=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.points_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a numpy array of 3D points to args for
a vertex list constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points to be rendered</p></li>
<li><p><strong>colors</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) or </em><em>(</em><em>n</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Colors for each point</p></li>
<li><p><strong>group</strong> (<em>str</em>) – Rendering group for the vertex list</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>args</strong> – Args for vertex list constructor</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(7,) tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.vector_to_gl">
<code class="sig-prename descclassname">trimesh.rendering.</code><code class="sig-name descname">vector_to_gl</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.vector_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array and an optional set of args into a
flat vector of gl.GLfloat</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.repair">
<span id="trimesh-repair-module"></span><h2>trimesh.repair module<a class="headerlink" href="#module-trimesh.repair" title="Permalink to this headline">¶</a></h2>
<div class="section" id="repair-py">
<h3>repair.py<a class="headerlink" href="#repair-py" title="Permalink to this headline">¶</a></h3>
<p>Fill holes and fix winding and normals of meshes.</p>
<dl class="function">
<dt id="trimesh.repair.broken_faces">
<code class="sig-prename descclassname">trimesh.repair.</code><code class="sig-name descname">broken_faces</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.broken_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of faces in the mesh which break the
watertight status of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p></li>
<li><p><strong>color</strong> (<em>(</em><em>4</em><em>,</em><em>) </em><em>uint8</em><em>, </em><em>will set broken faces to this color</em>) – None,       will not alter mesh colors</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>broken</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, ) int, indexes of mesh.faces</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fill_holes">
<code class="sig-prename descclassname">trimesh.repair.</code><code class="sig-name descname">fill_holes</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill single- triangle holes on triangular meshes by adding
new triangles to fill the holes. New triangles will have
proper winding and normals, and if face colors exist the color
of the last face will be assigned to the new triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Mesh will be repaired in- place</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_inversion">
<code class="sig-prename descclassname">trimesh.repair.</code><code class="sig-name descname">fix_inversion</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">multibody=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if a mesh has normals pointing “out.”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p></li>
<li><p><strong>multibody</strong> (<em>bool</em><em>, </em><em>if True will try to fix normals on every body</em>) – </p></li>
<li><p><strong>Alters</strong> – </p></li>
<li><p><strong>-------------</strong> – </p></li>
<li><p><strong>mesh.face</strong> (<em>may reverse faces</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_normals">
<code class="sig-prename descclassname">trimesh.repair.</code><code class="sig-name descname">fix_normals</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">multibody=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix the winding and direction of a mesh face and
face normals in-place.</p>
<p>Really only meaningful on watertight meshes, but will orient all
faces and winding in a uniform way for non-watertight face
patches as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p></li>
<li><p><strong>multibody</strong> (<em>bool</em><em>, </em><em>if True try to correct normals direction</em>) – on every body.</p></li>
<li><p><strong>Alters</strong> – </p></li>
<li><p><strong>--------------</strong> – </p></li>
<li><p><strong>mesh.faces</strong> (<em>will flip columns on inverted faces</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_winding">
<code class="sig-prename descclassname">trimesh.repair.</code><code class="sig-name descname">fix_winding</code><span class="sig-paren">(</span><em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_winding" title="Permalink to this definition">¶</a></dt>
<dd><p>Traverse and change mesh faces in-place to make sure winding
is correct, with edges on adjacent faces in
opposite directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>Trimesh object</em>) – </p></li>
<li><p><strong>Alters</strong> – </p></li>
<li><p><strong>-------------</strong> – </p></li>
<li><p><strong>mesh.face</strong> (<em>will reverse columns of certain faces</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.sample">
<span id="trimesh-sample-module"></span><h2>trimesh.sample module<a class="headerlink" href="#module-trimesh.sample" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sample-py">
<h3>sample.py<a class="headerlink" href="#sample-py" title="Permalink to this headline">¶</a></h3>
<p>Randomly sample surface and volume of meshes.</p>
<dl class="function">
<dt id="trimesh.sample.sample_surface">
<code class="sig-prename descclassname">trimesh.sample.</code><code class="sig-name descname">sample_surface</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the surface of a mesh, returning the specified
number of points</p>
<p>For individual triangle sampling uses this method:
<a class="reference external" href="http://mathworld.wolfram.com/TrianglePointPicking.html">http://mathworld.wolfram.com/TrianglePointPicking.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Geometry to sample the surface of</p></li>
<li><p><strong>count</strong> (<em>int</em>) – Number of points to return</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>samples</strong> (<em>(count, 3) float</em>) – Points in space on the surface of mesh</p></li>
<li><p><strong>face_index</strong> (<em>(count,) int</em>) – Indices of faces for each sampled point</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.sample_surface_even">
<code class="sig-prename descclassname">trimesh.sample.</code><code class="sig-name descname">sample_surface_even</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface_even" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the surface of a mesh, returning samples which are
approximately evenly spaced. This is accomplished by sampling
and then rejecting pairs that are too close together.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Geometry to sample the surface of</p></li>
<li><p><strong>count</strong> (<em>int</em>) – Number of points to return</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>samples</strong> (<em>(count, 3) float</em>) – Points in space on the surface of mesh</p></li>
<li><p><strong>face_index</strong> (<em>(count,) int</em>) – Indices of faces for each sampled point</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.sample_surface_sphere">
<code class="sig-prename descclassname">trimesh.sample.</code><code class="sig-name descname">sample_surface_sphere</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Correctly pick random points on the surface of a unit sphere</p>
<p>Uses this method:
<a class="reference external" href="http://mathworld.wolfram.com/SpherePointPicking.html">http://mathworld.wolfram.com/SpherePointPicking.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>count</strong> (<em>int</em>) – Number of points to return</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points</strong> – Random points on the surface of a unit sphere</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(count, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.volume_mesh">
<code class="sig-prename descclassname">trimesh.sample.</code><code class="sig-name descname">volume_mesh</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.volume_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Use rejection sampling to produce points randomly
distributed in the volume of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Geometry to sample</p></li>
<li><p><strong>count</strong> (<em>int</em>) – Number of points to return</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>samples</strong> – Points in the volume of the mesh where n &lt;= count</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.volume_rectangular">
<code class="sig-prename descclassname">trimesh.sample.</code><code class="sig-name descname">volume_rectangular</code><span class="sig-paren">(</span><em class="sig-param">extents</em>, <em class="sig-param">count</em>, <em class="sig-param">transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.volume_rectangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples inside a rectangular volume,
useful for sampling inside oriented bounding boxes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>extents</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Side lengths of rectangular solid</p></li>
<li><p><strong>count</strong> (<em>int</em>) – Number of points to return</p></li>
<li><p><strong>transform</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Homogeneous transformation matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>samples</strong> – Points in requested volume</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(count, 3) float</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.schemas">
<span id="trimesh-schemas-module"></span><h2>trimesh.schemas module<a class="headerlink" href="#module-trimesh.schemas" title="Permalink to this headline">¶</a></h2>
<div class="section" id="schemas-py">
<h3>schemas.py<a class="headerlink" href="#schemas-py" title="Permalink to this headline">¶</a></h3>
<p>Tools for dealing with schemas, particularly JSONschema</p>
<dl class="function">
<dt id="trimesh.schemas.resolve_json">
<code class="sig-prename descclassname">trimesh.schemas.</code><code class="sig-name descname">resolve_json</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">resolver</em>, <em class="sig-param">recursive=True</em>, <em class="sig-param">fill_empty='{}'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.schemas.resolve_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a JSON Schema containing <cite>$ref</cite> keys, replace all
referenced URI values with their values using trimesh
Resolver objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> (<em>str</em>) – JSON text including <cite>$ref</cite> to other files</p></li>
<li><p><strong>resolver</strong> (<em>trimesh.visual.resolver.Resolver</em>) – Resolver to fetch referenced assets</p></li>
<li><p><strong>recursive</strong> (<em>bool</em>) – If True, resolve references in referenced files</p></li>
<li><p><strong>fill_empty</strong> (<em>str</em>) – What to replace empty references with</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – JSON text with references filled in</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.smoothing">
<span id="trimesh-smoothing-module"></span><h2>trimesh.smoothing module<a class="headerlink" href="#module-trimesh.smoothing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.smoothing.filter_humphrey">
<code class="sig-prename descclassname">trimesh.smoothing.</code><code class="sig-name descname">filter_humphrey</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">alpha=0.1</em>, <em class="sig-param">beta=0.5</em>, <em class="sig-param">iterations=10</em>, <em class="sig-param">laplacian_operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.filter_humphrey" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a mesh in-place using laplacian smoothing
and Humphrey filtering.</p>
<p>Articles
“Improved Laplacian Smoothing of Noisy Surface Meshes”
J. Vollmer, R. Mencl, and H. Muller</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Mesh to be smoothed in place</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Controls shrinkage, range is 0.0 - 1.0
If 0.0, not considered
If 1.0, no smoothing</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – Controls how aggressive smoothing is
If 0.0, no smoothing
If 1.0, full aggressiveness</p></li>
<li><p><strong>iterations</strong> (<em>int</em>) – Number of passes to run filter</p></li>
<li><p><strong>laplacian_operator</strong> (<em>None</em><em> or </em><em>scipy.sparse.coo.coo_matrix</em>) – Sparse matrix laplacian operator
Will be autogenerated if None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.smoothing.filter_laplacian">
<code class="sig-prename descclassname">trimesh.smoothing.</code><code class="sig-name descname">filter_laplacian</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">lamb=0.5</em>, <em class="sig-param">iterations=10</em>, <em class="sig-param">implicit_time_integration=False</em>, <em class="sig-param">volume_constraint=True</em>, <em class="sig-param">laplacian_operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.filter_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a mesh in-place using laplacian smoothing.
Articles
1 - “Improved Laplacian Smoothing of Noisy Surface Meshes”</p>
<blockquote>
<div><ol class="upperalpha simple" start="10">
<li><p>Vollmer, R. Mencl, and H. Muller</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>2 - “Implicit Fairing of Irregular Meshes using Diffusion</dt><dd><p>and Curvature Flow”. M. Desbrun,  M. Meyer,
P. Schroder, A.H.B. Caltech</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – </p></li>
<li><p><strong>to be smoothed in place</strong> (<em>Mesh</em>) – </p></li>
<li><p><strong>lamb</strong> (<em>float</em>) – </p></li>
<li><p><strong>speed constant</strong> (<em>Diffusion</em>) – </p></li>
<li><p><strong>0.0</strong><strong>, </strong><strong>no diffusion</strong> (<em>If</em>) – </p></li>
<li><p><strong>&gt; 0.0</strong><strong>, </strong><strong>diffusion occurs</strong> (<em>If</em>) – </p></li>
<li><p><strong>implicit_time_integration</strong> (<em>boolean</em>) – </p></li>
<li><p><strong>False</strong> (<em>if</em>) – -lamb &lt;= 1.0 - Stability Limit (Article 1)</p></li>
<li><p><strong>True</strong> (<em>if</em>) – -lamb no limit (Article 2)</p></li>
<li><p><strong>iterations</strong> (<em>int</em>) – </p></li>
<li><p><strong>of passes to run filter</strong> (<em>Number</em>) – </p></li>
<li><p><strong>laplacian_operator</strong> (<em>None</em><em> or </em><em>scipy.sparse.coo.coo_matrix</em>) – </p></li>
<li><p><strong>matrix laplacian operator</strong> (<em>Sparse</em>) – </p></li>
<li><p><strong>be autogenerated if None</strong> (<em>Will</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.smoothing.filter_taubin">
<code class="sig-prename descclassname">trimesh.smoothing.</code><code class="sig-name descname">filter_taubin</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">lamb=0.5</em>, <em class="sig-param">nu=0.5</em>, <em class="sig-param">iterations=10</em>, <em class="sig-param">laplacian_operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.filter_taubin" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a mesh in-place using laplacian smoothing
and taubin filtering.</p>
<p>Articles
“Improved Laplacian Smoothing of Noisy Surface Meshes”
J. Vollmer, R. Mencl, and H. Muller</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Mesh to be smoothed in place.</p></li>
<li><p><strong>lamb</strong> (<em>float</em>) – Controls shrinkage, range is 0.0 - 1.0</p></li>
<li><p><strong>nu</strong> (<em>float</em>) – Controls dilation, range is 0.0 - 1.0
Nu shall be between 0.0 &lt; 1.0/lambda - 1.0/nu &lt; 0.1</p></li>
<li><p><strong>iterations</strong> (<em>int</em>) – Number of passes to run the filter</p></li>
<li><p><strong>laplacian_operator</strong> (<em>None</em><em> or </em><em>scipy.sparse.coo.coo_matrix</em>) – Sparse matrix laplacian operator
Will be autogenerated if None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.smoothing.laplacian_calculation">
<code class="sig-prename descclassname">trimesh.smoothing.</code><code class="sig-name descname">laplacian_calculation</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">equal_weight=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.laplacian_calculation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a sparse matrix for laplacian operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a>) – Input geometry</p></li>
<li><p><strong>equal_weight</strong> (<em>bool</em>) – If True, all neighbors will be considered equally
If False, all neightbors will be weighted by inverse distance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>laplacian</strong> – Laplacian operator</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>scipy.sparse.coo.coo_matrix</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.transformations">
<span id="trimesh-transformations-module"></span><h2>trimesh.transformations module<a class="headerlink" href="#module-trimesh.transformations" title="Permalink to this headline">¶</a></h2>
<p>Homogeneous Transformation Matrices and Quaternions.</p>
<p>A library for calculating 4x4 matrices for translating, rotating, reflecting,
scaling, shearing, projecting, orthogonalizing, and superimposing arrays of
3D homogeneous coordinates as well as for converting between rotation matrices,
Euler angles, and quaternions. Also includes an Arcball control object and
functions to decompose transformation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p><a class="reference external" href="http://www.lfd.uci.edu/~gohlke/">Christoph Gohlke</a></p>
</dd>
<dt class="field-even">Organization</dt>
<dd class="field-even"><p>Laboratory for Fluorescence Dynamics, University of California, Irvine</p>
</dd>
<dt class="field-odd">Version</dt>
<dd class="field-odd"><p>2017.02.17</p>
</dd>
</dl>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="http://www.python.org">CPython 2.7 or 3.4</a></p></li>
<li><p><a class="reference external" href="http://www.np.org">numpy 1.9</a></p></li>
<li><p><a class="reference external" href="http://www.lfd.uci.edu/~gohlke/">Transformations.c 2015.03.19</a>
(recommended for speedup of some functions)</p></li>
</ul>
<p class="rubric">Notes</p>
<p>The API is not stable yet and is expected to change between revisions.</p>
<p>This Python code is not optimized for speed. Refer to the transformations.c
module for a faster implementation of some functions.</p>
<p>Documentation in HTML format can be generated with epydoc.</p>
<p>Matrices (M) can be inverted using np.linalg.inv(M), be concatenated using
np.dot(M0, M1), or transform homogeneous coordinate arrays (v) using
np.dot(M, v) for shape (4, <em>) column vectors, respectively
np.dot(v, M.T) for shape (</em>, 4) row vectors (“array of points”).</p>
<p>This module follows the “column vectors on the right” and “row major storage”
(C contiguous) conventions. The translation components are in the right column
of the transformation matrix, i.e. M[:3, 3].
The transpose of the transformation matrices may have to be used to interface
with other graphics systems, e.g. with OpenGL’s glMultMatrixd(). See also [16].</p>
<p>Calculations are carried out with np.float64 precision.</p>
<p>Vector, point, quaternion, and matrix function arguments are expected to be
“array like”, i.e. tuple, list, or numpy arrays.</p>
<p>Return types are numpy arrays unless specified otherwise.</p>
<p>Angles are in radians unless specified otherwise.</p>
<p>Quaternions w+ix+jy+kz are represented as [w, x, y, z].</p>
<p>A triple of Euler angles can be applied/interpreted in 24 ways, which can
be specified using a 4 character string or encoded 4-tuple:</p>
<blockquote>
<div><p><em>Axes 4-string</em>: e.g. ‘sxyz’ or ‘ryxy’</p>
<ul class="simple">
<li><p>first character : rotations are applied to ‘s’tatic or ‘r’otating frame</p></li>
<li><p>remaining characters : successive rotation axis ‘x’, ‘y’, or ‘z’</p></li>
</ul>
<p><em>Axes 4-tuple</em>: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)</p>
<ul class="simple">
<li><p>inner axis: code of axis (‘x’:0, ‘y’:1, ‘z’:2) of rightmost matrix.</p></li>
<li><p>parity : even (0) if inner axis ‘x’ is followed by ‘y’, ‘y’ is followed
by ‘z’, or ‘z’ is followed by ‘x’. Otherwise odd (1).</p></li>
<li><p>repetition : first and last axis are same (1) or different (0).</p></li>
<li><p>frame : rotations are applied to static (0) or rotating (1) frame.</p></li>
</ul>
</div></blockquote>
<p>Other Python packages and modules for 3D transformations and quaternions:</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://pypi.python.org/pypi/transforms3d">Transforms3d</a></dt><dd><p>includes most code of this module.</p>
</dd>
</dl>
</li>
<li><p><a class="reference external" href="http://www.blender.org/api/blender_python_api">Blender.mathutils</a></p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy-dtypes">numpy-dtypes</a></p></li>
</ul>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p>Matrices and transformations. Ronald Goldman.
In “Graphics Gems I”, pp 472-475. Morgan Kaufmann, 1990.</p></li>
<li><p>More matrices and transformations: shear and pseudo-perspective.
Ronald Goldman. In “Graphics Gems II”, pp 320-323. Morgan Kaufmann, 1991.</p></li>
<li><p>Decomposing a matrix into simple transformations. Spencer Thomas.
In “Graphics Gems II”, pp 320-323. Morgan Kaufmann, 1991.</p></li>
<li><p>Recovering the data from the transformation matrix. Ronald Goldman.
In “Graphics Gems II”, pp 324-331. Morgan Kaufmann, 1991.</p></li>
<li><p>Euler angle conversion. Ken Shoemake.
In “Graphics Gems IV”, pp 222-229. Morgan Kaufmann, 1994.</p></li>
<li><p>Arcball rotation control. Ken Shoemake.
In “Graphics Gems IV”, pp 175-192. Morgan Kaufmann, 1994.</p></li>
<li><p>Representing attitude: Euler angles, unit quaternions, and rotation
vectors. James Diebel. 2006.</p></li>
<li><p>A discussion of the solution for the best rotation to relate two sets
of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.</p></li>
<li><p>Closed-form solution of absolute orientation using unit quaternions.
BKP Horn. J Opt Soc Am A. 1987. 4(4):629-642.</p></li>
<li><p>Quaternions. Ken Shoemake.
<a class="reference external" href="http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf">http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf</a></p></li>
<li><p>From quaternion to matrix and back. JMP van Waveren. 2005.
<a class="reference external" href="http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm">http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm</a></p></li>
<li><p>Uniform random rotations. Ken Shoemake.
In “Graphics Gems III”, pp 124-132. Morgan Kaufmann, 1992.</p></li>
<li><p>Quaternion in molecular modeling. CFF Karney.
J Mol Graph Mod, 25(5):595-604</p></li>
<li><p>New method for extracting the quaternion from a rotation matrix.
Itzhack Y Bar-Itzhack, J Guid Contr Dynam. 2000. 23(6): 1085-1087.</p></li>
<li><p>Multiple View Geometry in Computer Vision. Hartley and Zissermann.
Cambridge University Press; 2nd Ed. 2004. Chapter 4, Algorithm 4.7, p 130.</p></li>
<li><p>Column Vectors vs. Row Vectors.
<a class="reference external" href="http://steve.hollasch.net/cgindex/math/matrix/column-vec.html">http://steve.hollasch.net/cgindex/math/matrix/column-vec.html</a></p></li>
</ol>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.123</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.234</span><span class="p">,</span> <span class="mf">2.345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">origin</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="n">zaxis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rx</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ry</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rz</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">concatenate_matrices</span><span class="p">(</span><span class="n">Rx</span><span class="p">,</span> <span class="n">Ry</span><span class="p">,</span> <span class="n">Rz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler</span> <span class="o">=</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">],</span> <span class="n">euler</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Re</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Re</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">al</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ga</span> <span class="o">=</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">Re</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">Re</span><span class="p">,</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">al</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ga</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qx</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qy</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qz</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rq</span> <span class="o">=</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Rq</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">scale_matrix</span><span class="p">(</span><span class="mf">1.23</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">translation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span> <span class="o">=</span> <span class="n">shear_matrix</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">random_rotation_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">concatenate_matrices</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span> <span class="o">=</span> <span class="n">decompose_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s1">&#39;sxyz&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M1</span> <span class="o">=</span> <span class="n">compose_matrix</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">random_vector</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">),</span> <span class="n">vector_product</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">v2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="module-trimesh.triangles">
<span id="trimesh-triangles-module"></span><h2>trimesh.triangles module<a class="headerlink" href="#module-trimesh.triangles" title="Permalink to this headline">¶</a></h2>
<div class="section" id="triangles-py">
<h3>triangles.py<a class="headerlink" href="#triangles-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for dealing with triangle soups in (n, 3, 3) float form.</p>
<dl class="function">
<dt id="trimesh.triangles.all_coplanar">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">all_coplanar</code><span class="sig-paren">(</span><em class="sig-param">triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.all_coplanar" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if a list of triangles are all coplanar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertices of triangles</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>all_coplanar</strong> – True if all triangles are coplanar</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.angles">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">angles</code><span class="sig-paren">(</span><em class="sig-param">triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the angles of input triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertex positions</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>angles</strong> – Angles at vertex positions in radians
Degenerate angles will be returned as zero</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.any_coplanar">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">any_coplanar</code><span class="sig-paren">(</span><em class="sig-param">triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.any_coplanar" title="Permalink to this definition">¶</a></dt>
<dd><p>For a list of triangles if the FIRST triangle is coplanar
with ANY of the following triangles, return True.
Otherwise, return False.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.area">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">area</code><span class="sig-paren">(</span><em class="sig-param">triangles=None</em>, <em class="sig-param">crosses=None</em>, <em class="sig-param">sum=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the sum area of input triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertices of triangles</p></li>
<li><p><strong>crosses</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em><em> or </em><em>None</em>) – As a speedup don’t re- compute cross products</p></li>
<li><p><strong>sum</strong> (<em>bool</em>) – Return summed area or individual triangle area</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>area</strong> – Individual or summed area depending on <cite>sum</cite> argument</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float or float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.barycentric_to_points">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">barycentric_to_points</code><span class="sig-paren">(</span><em class="sig-param">triangles</em>, <em class="sig-param">barycentric</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.barycentric_to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of barycentric coordinates on a list of triangles
to cartesian points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangles in space</p></li>
<li><p><strong>barycentric</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>float</em>) – Barycentric coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points</strong> – Points in space</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.bounds_tree">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">bounds_tree</code><span class="sig-paren">(</span><em class="sig-param">triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.bounds_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of triangles, create an r-tree for broad- phase
collision detection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangles in space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tree</strong> – One node per triangle</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>rtree.Rtree</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.closest_point">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">closest_point</code><span class="sig-paren">(</span><em class="sig-param">triangles</em>, <em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closest point on the surface of each triangle for a
list of corresponding points.</p>
<p>Implements the method from “Real Time Collision Detection” and
use the same variable names as “ClosestPtPointTriangle” to avoid
being any more confusing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangle vertices in space</p></li>
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points in space</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>closest</strong> – Point on each triangle closest to each point</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.cross">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">cross</code><span class="sig-paren">(</span><em class="sig-param">triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cross product of two edges from input triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertices of triangles</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>crosses</strong> – Cross product of two edge vectors</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.extents">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">extents</code><span class="sig-paren">(</span><em class="sig-param">triangles</em>, <em class="sig-param">areas=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D bounding box size of each triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangles in space</p></li>
<li><p><strong>areas</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Optional area of input triangles</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>box</strong> – The size of each triangle’s 2D oriented bounding box</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 2) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.mass_properties">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">mass_properties</code><span class="sig-paren">(</span><em class="sig-param">triangles</em>, <em class="sig-param">crosses=None</em>, <em class="sig-param">density=1.0</em>, <em class="sig-param">center_mass=None</em>, <em class="sig-param">skip_inertia=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.mass_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mass properties of a group of triangles.</p>
<p>Implemented from:
<a class="reference external" href="http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf">http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangle vertices in space</p></li>
<li><p><strong>crosses</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Optional cross products of triangles</p></li>
<li><p><strong>density</strong> (<em>float</em>) – Optional override for density</p></li>
<li><p><strong>center_mass</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Optional override for center mass</p></li>
<li><p><strong>skip_inertia</strong> (<em>bool</em>) – if True will not return moments matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>info</strong> – Mass properties</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.nondegenerate">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">nondegenerate</code><span class="sig-paren">(</span><em class="sig-param">triangles</em>, <em class="sig-param">areas=None</em>, <em class="sig-param">height=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.nondegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all triangles which have an oriented bounding box
where both of the two sides is larger than a specified height.</p>
<p>Degenerate triangles can be when:
1) Two of the three vertices are colocated
2) All three vertices are unique but colinear</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangles in space</p></li>
<li><p><strong>height</strong> (<em>float</em>) – Minimum edge length of a triangle to keep</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nondegenerate</strong> – True if a triangle meets required minimum height</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.normals">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">normals</code><span class="sig-paren">(</span><em class="sig-param">triangles=None</em>, <em class="sig-param">crosses=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normals of input triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertex positions</p></li>
<li><p><strong>crosses</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Cross products of edge vectors</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>normals</strong> (<em>(m, 3) float</em>) – Normal vectors</p></li>
<li><p><strong>valid</strong> (<em>(n,) bool</em>) – Was the face nonzero area or not</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.points_to_barycentric">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">points_to_barycentric</code><span class="sig-paren">(</span><em class="sig-param">triangles</em>, <em class="sig-param">points</em>, <em class="sig-param">method='cramer'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.points_to_barycentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the barycentric coordinates of points relative to triangles.</p>
<dl class="simple">
<dt>The Cramer’s rule solution implements:</dt><dd><p><a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a></p>
</dd>
<dt>The cross product solution implements:</dt><dd><p><a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangles vertices in space</p></li>
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Point in space associated with a triangle</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <dl class="simple">
<dt>Which method to compute the barycentric coordinates with:</dt><dd><ul>
<li><dl class="simple">
<dt>’cross’: uses a method using cross products, roughly 2x slower but</dt><dd><p>different numerical robustness properties</p>
</dd>
</dl>
</li>
<li><p>anything else: uses a cramer’s rule solution</p></li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>barycentric</strong> – Barycentric coordinates of each point</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.to_kwargs">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">to_kwargs</code><span class="sig-paren">(</span><em class="sig-param">triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.to_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of triangles to the kwargs for the Trimesh
constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Triangles in space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>kwargs</strong> – Keyword arguments for the trimesh.Trimesh constructor
Includes keys ‘vertices’ and ‘faces’</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="o">**</span><span class="n">trimesh</span><span class="o">.</span><span class="n">triangles</span><span class="o">.</span><span class="n">to_kwargs</span><span class="p">(</span><span class="n">triangles</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.windings_aligned">
<code class="sig-prename descclassname">trimesh.triangles.</code><code class="sig-name descname">windings_aligned</code><span class="sig-paren">(</span><em class="sig-param">triangles</em>, <em class="sig-param">normals_compare</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.windings_aligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of triangles and a list of normals determine if the
two are aligned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>triangles</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Vertex locations in space</p></li>
<li><p><strong>normals_compare</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – List of normals to compare</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>aligned</strong> – Are normals aligned with triangles</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) bool</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.units">
<span id="trimesh-units-module"></span><h2>trimesh.units module<a class="headerlink" href="#module-trimesh.units" title="Permalink to this headline">¶</a></h2>
<div class="section" id="units-py">
<h3>units.py<a class="headerlink" href="#units-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with physical unit systems (i.e. inches, mm)</p>
<p>Very basic conversions, and no requirement for
sympy.physics.units or pint.</p>
<dl class="function">
<dt id="trimesh.units.unit_conversion">
<code class="sig-prename descclassname">trimesh.units.</code><code class="sig-name descname">unit_conversion</code><span class="sig-paren">(</span><em class="sig-param">current</em>, <em class="sig-param">desired</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.units.unit_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the conversion from one set of units to another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current</strong> (<em>str</em>) – Unit system values are in now (eg ‘millimeters’)</p></li>
<li><p><strong>desired</strong> (<em>str</em>) – Unit system we’d like values in (eg ‘inches’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>conversion</strong> – Number to multiply by to put values into desired units</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.units.units_from_metadata">
<code class="sig-prename descclassname">trimesh.units.</code><code class="sig-name descname">units_from_metadata</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">guess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.units.units_from_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract hints from metadata and if that fails
guess based on the object scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>object</em>) – Has attributes ‘metadata’ (dict) and ‘scale’ (float)</p></li>
<li><p><strong>guess</strong> (<em>bool</em>) – If metadata doesn’t indicate units, guess from scale</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>units</strong> – A guess of what the units might be</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.util">
<span id="trimesh-util-module"></span><h2>trimesh.util module<a class="headerlink" href="#module-trimesh.util" title="Permalink to this headline">¶</a></h2>
<div class="section" id="util-py">
<h3>util.py<a class="headerlink" href="#util-py" title="Permalink to this headline">¶</a></h3>
<p>Standalone functions which require only imports from numpy and the
standard library.</p>
<p>Other libraries may be imported must be wrapped in try/except blocks
or imported inside of a function</p>
<dl class="class">
<dt id="trimesh.util.FunctionRegistry">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">FunctionRegistry</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.FunctionRegistry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></p>
<p>Non-overwritable mapping of string keys to functions.</p>
<p>This allows external packages to register additional implementations
of common functionality without risk of breaking implementations provided
by trimesh.</p>
<p>See trimesh.voxel.morphology for example usage.</p>
</dd></dl>

<dl class="class">
<dt id="trimesh.util.TemporaryDirectory">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">TemporaryDirectory</code><a class="headerlink" href="#trimesh.util.TemporaryDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Same basic usage as tempfile.TemporaryDirectory
but functional in Python 2.7+</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.allclose">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">allclose</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">atol</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.allclose" title="Permalink to this definition">¶</a></dt>
<dd><p>A replacement for np.allclose that does few checks
and validation and as a result is faster.</p>
<blockquote>
<div><p>Note that this is used in tight loops, and as such</p>
</div></blockquote>
<p>a and b MUST be np.ndarray, not list or “array-like”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em>) – To be compared</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em>) – To be compared</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – Acceptable distance between <cite>a</cite> and <cite>b</cite> to be “close”</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool indicating if all elements are within <cite>atol</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.append_faces">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">append_faces</code><span class="sig-paren">(</span><em class="sig-param">vertices_seq</em>, <em class="sig-param">faces_seq</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.append_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of zero- indexed faces and vertices
combine them into a single array of faces and
a single array of vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices_seq</strong> (<em>(</em><em>n</em><em>, </em><em>) </em><em>sequence of</em><em> (</em><em>m</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Multiple arrays of verticesvertex arrays</p></li>
<li><p><strong>faces_seq</strong> (<em>(</em><em>n</em><em>, </em><em>) </em><em>sequence of</em><em> (</em><em>p</em><em>, </em><em>j</em><em>) </em><em>int</em>) – Zero indexed faces for matching vertices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vertices</strong> (<em>(i, d) float</em>) – Points in space</p></li>
<li><p><strong>faces</strong> (<em>(j, 3) int</em>) – Reference vertex indices</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.array_to_encoded">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">array_to_encoded</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">encoding='base64'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.array_to_encoded" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a numpy array to a compact serializable dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>array</em>) – Any numpy array</p></li>
<li><p><strong>dtype</strong> (<em>str</em><em> or </em><em>None</em>) – Optional dtype to encode array</p></li>
<li><p><strong>encoding</strong> (<em>str</em>) – ‘base64’ or ‘binary’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>encoded</strong> – Has keys:
‘dtype’:  str, of dtype
‘shape’:  tuple of shape
‘base64’: str, base64 encoded string</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.array_to_string">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">array_to_string</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">col_delim=' '</em>, <em class="sig-param">row_delim='\n'</em>, <em class="sig-param">digits=8</em>, <em class="sig-param">value_format='{}'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.array_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a 1 or 2D array into a string with a specified number
of digits and delimiter. The reason this exists is that the
basic numpy array to string conversions are surprisingly bad.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>(</em><em>n</em><em>,</em><em>) or </em><em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em><em> or </em><em>int</em>) – Data to be converted
If shape is (n,) only column delimiter will be used</p></li>
<li><p><strong>col_delim</strong> (<em>str</em>) – What string should separate values in a column</p></li>
<li><p><strong>row_delim</strong> (<em>str</em>) – What string should separate values in a row</p></li>
<li><p><strong>digits</strong> (<em>int</em>) – How many digits should floating point numbers include</p></li>
<li><p><strong>value_format</strong> (<em>str</em>) – Format string for each value or sequence of values
If multiple values per value_format it must divide
into array evenly.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>formatted</strong> – String representation of original array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.attach_to_log">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">attach_to_log</code><span class="sig-paren">(</span><em class="sig-param">level=10</em>, <em class="sig-param">handler=None</em>, <em class="sig-param">loggers=None</em>, <em class="sig-param">colors=True</em>, <em class="sig-param">capture_warnings=True</em>, <em class="sig-param">blacklist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.attach_to_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a stream handler to all loggers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level</strong> (<em>logging level</em>) – </p></li>
<li><p><strong>handler</strong> (<em>log handler object</em>) – </p></li>
<li><p><strong>loggers</strong> (<em>list of loggers to attach to</em>) – if None, will try to attach to all available</p></li>
<li><p><strong>colors</strong> (<em>bool</em><em>, </em><em>if True try to use colorlog formatter</em>) – </p></li>
<li><p><strong>blacklist</strong> (<em>list of str</em><em>, </em><em>names of loggers NOT to attach to</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.bounds_tree">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">bounds_tree</code><span class="sig-paren">(</span><em class="sig-param">bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.bounds_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of axis aligned bounds, create an r-tree for broad- phase
collision detection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bounds</strong> (<em>(</em><em>n</em><em>, </em><em>dimension*2</em><em>) </em><em>list of non- interleaved bounds</em>) – for a 2D bounds tree:
[(minx, miny, maxx, maxy), …]</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tree</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rtree object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.compress">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">compress</code><span class="sig-paren">(</span><em class="sig-param">info</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compress data stored in a dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>info</strong> (<em>dict</em>) – Data to compress in form:
{file name in archive: bytes or file-like object}</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>compressed</strong> – Compressed file data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.concatenate">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">concatenate</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two or more meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Trimesh object</em><em>, or </em><em>list of such</em>) – </p></li>
<li><p><strong>b</strong> (<em>Trimesh object</em><em>, or </em><em>list of such</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Trimesh object containing concatenated mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.convert_like">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">convert_like</code><span class="sig-paren">(</span><em class="sig-param">item</em>, <em class="sig-param">like</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.convert_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an item to have the dtype of another item</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>item</strong> (<em>item to be converted</em>) – </p></li>
<li><p><strong>like</strong> (<em>object with target dtype. If None</em><em>, </em><em>item is returned unmodified</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>item, but in dtype of like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decimal_to_digits">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">decimal_to_digits</code><span class="sig-paren">(</span><em class="sig-param">decimal</em>, <em class="sig-param">min_digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decimal_to_digits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of digits to the first nonzero decimal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>decimal</strong> (<em>float</em>) – </p></li>
<li><p><strong>min_digits</strong> (<em>int</em><em>, </em><em>minimum number of digits to return</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>digits</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, number of digits to the first nonzero decimal</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decode_keys">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">decode_keys</code><span class="sig-paren">(</span><em class="sig-param">store</em>, <em class="sig-param">encoding='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decode_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>If a dictionary has keys that are bytes decode them to a str.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>store</strong> (<em>dict</em>) – Dictionary with data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Values are untouched but keys that were bytes
are converted to ASCII strings.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>In [1]: d
Out[1]: {1020: ‘nah’, b’hi’: ‘stuff’}</p>
<p>In [2]: trimesh.util.decode_keys(d)
Out[2]: {1020: ‘nah’, ‘hi’: ‘stuff’}</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decode_text">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">decode_text</code><span class="sig-paren">(</span><em class="sig-param">text</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decode_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to decode byte input as a string.</p>
<p>Initially guesses that text is UTF-8, and then if
that fails it tries to detect the encoding and
try once more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>bytes</em>) – Data that might be strings</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>decoded</strong> – Data as a string</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decompress">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">decompress</code><span class="sig-paren">(</span><em class="sig-param">file_obj</em>, <em class="sig-param">file_type</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an open file object and a file type, return all components
of the archive as open file objects in a dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> (<em>file-like</em>) – Containing compressed data</p></li>
<li><p><strong>file_type</strong> (<em>str</em>) – File extension, ‘zip’, ‘tar.gz’, etc</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>decompressed</strong> – Data from archive in format {file name : file-like}</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.diagonal_dot">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">diagonal_dot</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.diagonal_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product by row of a and b.</p>
<p>There are a lot of ways to do this though
performance varies very widely. This method
uses the dot product to sum the row and avoids
function calls if at all possible.</p>
<p>Comparing performance of some equivalent versions:
<a href="#id21"><span class="problematic" id="id22">``</span></a>`
In [1]: import numpy as np; import trimesh</p>
<p>In [2]: a = np.random.random((10000, 3))</p>
<p>In [3]: b = np.random.random((10000, 3))</p>
<p>In [4]: %timeit (a * b).sum(axis=1)
1000 loops, best of 3: 181 us per loop</p>
<p>In [5]: %timeit np.einsum(‘ij,ij-&gt;i’, a, b)
10000 loops, best of 3: 62.7 us per loop</p>
<p>In [6]: %timeit np.diag(np.dot(a, b.T))
1 loop, best of 3: 429 ms per loop</p>
<p>In [7]: %timeit np.dot(a * b, np.ones(a.shape[1]))
10000 loops, best of 3: 61.3 us per loop</p>
<p>In [8]: %timeit trimesh.util.diagonal_dot(a, b)
10000 loops, best of 3: 55.2 us per loop
<a href="#id23"><span class="problematic" id="id24">``</span></a><a href="#id25"><span class="problematic" id="id26">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>m</em><em>, </em><em>d</em><em>) </em><em>float</em>) – First array</p></li>
<li><p><strong>b</strong> (<em>(</em><em>m</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Second array</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Dot product of each row</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.distance_to_end">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">distance_to_end</code><span class="sig-paren">(</span><em class="sig-param">file_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.distance_to_end" title="Permalink to this definition">¶</a></dt>
<dd><p>For an open file object how far is it to the end</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file_obj</strong> (<em>open file- like object</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>distance</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int, bytes to end of file</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.encoded_to_array">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">encoded_to_array</code><span class="sig-paren">(</span><em class="sig-param">encoded</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.encoded_to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a dictionary with base64 encoded strings back into a numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>encoded</strong> (<em>dict</em>) – <dl class="simple">
<dt>Has keys:</dt><dd><p>dtype: string of dtype
shape: int tuple of shape
base64: base64 encoded string of flat array
binary:  decode result coming from numpy.tostring</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.euclidean">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">euclidean</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.euclidean" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean distance between vectors a and b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – First vector</p></li>
<li><p><strong>b</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Second vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>distance</strong> – Euclidean distance between A and B</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.generate_basis">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">generate_basis</code><span class="sig-paren">(</span><em class="sig-param">z</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.generate_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an arbitrary basis (also known as a coordinate frame)
from a given z-axis vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>z</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – A vector along the positive z-axis</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> (<em>(3,) float</em>) – Vector along x axis</p></li>
<li><p><strong>y</strong> (<em>(3,) float</em>) – Vector along y axis</p></li>
<li><p><strong>z</strong> (<em>(3,) float</em>) – Vector along z axis</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.grid_arange">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">grid_arange</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">step</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.grid_arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a grid from an (2,dimension) bounds with samples step distance apart.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>(</em><em>2</em><em>,</em><em>dimension</em><em>) </em><em>list of</em><em> [</em><em>[</em><em>min x</em><em>, </em><em>min y</em><em>, </em><em>etc</em><em>]</em><em>, </em><em>[</em><em>max x</em><em>, </em><em>max y</em><em>, </em><em>etc</em><em>]</em><em>]</em>) – </p></li>
<li><p><strong>step</strong> (<em>float</em><em>, or </em><em>(</em><em>dimension</em><em>) </em><em>floats</em><em>, </em><em>separation between points</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grid</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, dimension), points inside the specified bounds</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.grid_linspace">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">grid_linspace</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.grid_linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a grid spaced inside a bounding box with edges spaced using np.linspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>(</em><em>2</em><em>,</em><em>dimension</em><em>) </em><em>list of</em><em> [</em><em>[</em><em>min x</em><em>, </em><em>min y</em><em>, </em><em>etc</em><em>]</em><em>, </em><em>[</em><em>max x</em><em>, </em><em>max y</em><em>, </em><em>etc</em><em>]</em><em>]</em>) – </p></li>
<li><p><strong>count</strong> (<em>int</em><em>, or </em><em>(</em><em>dimension</em><em>,</em><em>) </em><em>int</em><em>, </em><em>number of samples per side</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grid</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, dimension) float, points in the specified bounds</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.hash_file">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">hash_file</code><span class="sig-paren">(</span><em class="sig-param">file_obj</em>, <em class="sig-param">hash_function=&lt;built-in function openssl_md5&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.hash_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the hash of an open file- like object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> (<em>file like object</em>) – </p></li>
<li><p><strong>hash_function</strong> (<em>function to use to hash data</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hashed</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str, hex version of result</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_binary_file">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">is_binary_file</code><span class="sig-paren">(</span><em class="sig-param">file_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_binary_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if file has non-ASCII characters (&gt; 0x7F, or 127)
Should work in both Python 2 and 3</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_file">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">is_file</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is file- like</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>object</em>) – Any object type to be checked</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_file</strong> – True if object is a file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_instance_named">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">is_instance_named</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_instance_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an object, if it is a member of the class ‘name’,
or a subclass of ‘name’, return True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>instance</em>) – Some object of some class</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name of the class we want to check for</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_instance</strong> – Whether the object is a member of the named class</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_none">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">is_none</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if an object is None or not.</p>
<p>Handles the case of np.array(None) as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>object</em>) – Any object type to be checked</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_none</strong> – True if obj is None or numpy None-like</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_sequence">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">is_sequence</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is a sequence or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>object</em>) – Any object type to be checked</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_sequence</strong> – True if object is sequence</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_shape">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">is_shape</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">shape</em>, <em class="sig-param">allow_zeros=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the shape of a numpy.ndarray to a target shape,
with any value less than zero being considered a wildcard</p>
<p>Note that if a list- like object is passed that is not a numpy
array, this function will not convert it and will return False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>np.ndarray</em>) – Array to check the shape on</p></li>
<li><p><strong>shape</strong> (<em>list</em><em> or </em><em>tuple</em>) – Any negative term will be considered a wildcard
Any tuple term will be evaluated as an OR</p></li>
<li><p><strong>allow_zeros</strong> (<em>bool</em>) – if False, zeros do not math negatives in shape.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>shape_ok</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool, True if shape of obj matches query shape</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: a = np.random.random((100, 3))</p>
<p>In [2]: a.shape
Out[2]: (100, 3)</p>
<p>In [3]: trimesh.util.is_shape(a, (-1, 3))
Out[3]: True</p>
<p>In [4]: trimesh.util.is_shape(a, (-1, 3, 5))
Out[4]: False</p>
<p>In [5]: trimesh.util.is_shape(a, (100, -1))
Out[5]: True</p>
<p>In [6]: trimesh.util.is_shape(a, (-1, (3, 4)))
Out[6]: True</p>
<p>In [7]: trimesh.util.is_shape(a, (-1, (4, 5)))
Out[7]: False</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_string">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">is_string</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>object</em>) – Any object type to be checked</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_string</strong> – True if obj is a string</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.isclose">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">isclose</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">atol</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.isclose" title="Permalink to this definition">¶</a></dt>
<dd><p>A replacement for np.isclose that does fewer checks
and validation and as a result is roughly 4x faster.</p>
<p>Note that this is used in tight loops, and as such
a and b MUST be np.ndarray, not list or “array-like”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em>) – To be compared</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em>) – To be compared</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – Acceptable distance between <cite>a</cite> and <cite>b</cite> to be “close”</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>close</strong> – Per- element closeness</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray, bool</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.jsonify">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">jsonify</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.jsonify" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of json.dumps that can handle numpy arrays
by creating a custom encoder for numpy dtypes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>JSON- serializable blob</em>) – </p></li>
<li><p><strong>**kwargs</strong> – Passed to json.dumps</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dumped</strong> – JSON dump of obj</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.make_sequence">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">make_sequence</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.make_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an object, if it is a sequence return, otherwise
add it to a length 1 sequence and return.</p>
<p>Useful for wrapping functions which sometimes return single
objects and other times return lists of objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>object</em>) – An object to be made a sequence</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>as_sequence</strong> – Contains input value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) sequence</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.md5_object">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">md5_object</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.md5_object" title="Permalink to this definition">¶</a></dt>
<dd><p>If an object is hashable, return the string of the MD5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> (<em>object</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>md5</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str, MD5 hash</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.multi_dict">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">multi_dict</code><span class="sig-paren">(</span><em class="sig-param">pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.multi_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of key value pairs, create a dictionary.
If a key occurs multiple times, stack the values into an array.</p>
<p>Can be called like the regular dict(pairs) constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pairs</strong> (<em>(</em><em>n</em><em>,</em><em>2</em><em>) </em><em>array of key</em><em>, </em><em>value pairs</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict, with all values stored (rather than last with regular dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.pairwise">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">pairwise</code><span class="sig-paren">(</span><em class="sig-param">iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>For an iterable, group values into pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iterable</strong> (<em>(</em><em>m</em><em>, </em><em>) </em><em>list</em>) – A sequence of values</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pairs</strong> – Pairs of sequential values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 2)</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>In [1]: data
Out[1]: [0, 1, 2, 3, 4, 5, 6]</p>
<p>In [2]: list(trimesh.util.pairwise(data))
Out[2]: [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.row_norm">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">row_norm</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.row_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm per- row of a numpy array.</p>
<p>This is identical to np.linalg.norm(data, axis=1) but roughly
three times faster due to being less general.</p>
<p>In [3]: %timeit trimesh.util.row_norm(a)
76.3 us +/- 651 ns per loop</p>
<p>In [4]: %timeit np.linalg.norm(a, axis=1)
220 us +/- 5.41 us per loop</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Input 2D data to calculate per- row norm of</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>norm</strong> – Norm of each row of input array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.sigfig_int">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">sigfig_int</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">sigfig</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.sigfig_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of floating point values into integers with a specified number
of significant figures and an exponent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em><em> or </em><em>int</em><em>, </em><em>array of values</em>) – </p></li>
<li><p><strong>sigfig</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>int</em><em>, </em><em>number of significant figures to keep</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>as_int</strong> (<em>(n,) int, every value[i] has sigfig[i] digits</em>)</p></li>
<li><p><strong>multiplier</strong> (<em>(n, int), exponent, so as_int * 10 *</em> multiplier is*) – the same order of magnitude as the input</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.sigfig_round">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">sigfig_round</code><span class="sig-paren">(</span><em class="sig-param">values</em>, <em class="sig-param">sigfig=1</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.sigfig_round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round a single value to a specified number of significant figures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>float</em><em>, </em><em>value to be rounded</em>) – </p></li>
<li><p><strong>sigfig</strong> (<em>int</em><em>, </em><em>number of significant figures to reduce to</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rounded</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>values, but rounded to the specified number of significant figures</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: trimesh.util.round_sigfig(-232453.00014045456, 1)
Out[1]: -200000.0</p>
<p>In [2]: trimesh.util.round_sigfig(.00014045456, 1)
Out[2]: 0.0001</p>
<p>In [3]: trimesh.util.round_sigfig(.00014045456, 4)
Out[3]: 0.0001405</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.spherical_to_vector">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">spherical_to_vector</code><span class="sig-paren">(</span><em class="sig-param">spherical</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.spherical_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of (n,2) spherical vectors to (n,3) vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>spherical</strong> (<em>(</em><em>n</em><em> , </em><em>2</em><em>) </em><em>float</em>) – Angles, in radians</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vectors</strong> – Unit vectors</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.split_extension">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">split_extension</code><span class="sig-paren">(</span><em class="sig-param">file_name, special=['tar.bz2', 'tar.gz']</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.split_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the file extension of a file name, including support for
special case multipart file extensions (like .tar.gz)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> (<em>str</em><em>, </em><em>file name</em>) – </p></li>
<li><p><strong>special</strong> (<em>list of str</em><em>, </em><em>multipart extensions</em>) – eg: [‘tar.bz2’, ‘tar.gz’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>extension</strong> – a value from ‘special’</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str, last characters after a period, or</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.stack_3D">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">stack_3D</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">return_2D=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.stack_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>For a list of (n, 2) or (n, 3) points return them
as (n, 3) 3D points, 2D points on the XY plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>2</em><em>) or </em><em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points in either 2D or 3D space</p></li>
<li><p><strong>return_2D</strong> (<em>bool</em>) – Were the original points 2D?</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>points</strong> (<em>(n, 3) float</em>) – Points in space</p></li>
<li><p><strong>is_2D</strong> (<em>bool</em>) – Only returned if return_2D
If source points were (n, 2) True</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.stack_lines">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">stack_lines</code><span class="sig-paren">(</span><em class="sig-param">indices</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.stack_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack a list of values that represent a polyline into
individual line segments with duplicated consecutive values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>indices</strong> (<em>sequence of items</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>stacked</strong> (<em>(n,2) set of items</em>)</p></li>
<li><p><strong>In [1]</strong> (<em>trimesh.util.stack_lines([0,1,2])</em>)</p></li>
<li><p><em>Out[1]</em></p></li>
<li><p><em>array([[0, 1],</em> – [1, 2]])</p></li>
<li><p><strong>In [2]</strong> (<em>trimesh.util.stack_lines([0,1,2,4,5])</em>)</p></li>
<li><p><em>Out[2]</em></p></li>
<li><p><em>array([[0, 1],</em> – [1, 2],
[2, 4],
[4, 5]])</p></li>
<li><p><strong>In [3]</strong> (<em>trimesh.util.stack_lines([[0,0],[1,1],[2,2], [3,3]])</em>)</p></li>
<li><p><em>Out[3]</em></p></li>
<li><p><em>array([[0, 0],</em> – [1, 1],
[1, 1],
[2, 2],
[2, 2],
[3, 3]])</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.submesh">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">submesh</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">faces_sequence</em>, <em class="sig-param">only_watertight=False</em>, <em class="sig-param">append=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.submesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a>) – Source mesh to take geometry from</p></li>
<li><p><strong>faces_sequence</strong> (<em>sequence</em><em> (</em><em>p</em><em>,</em><em>) </em><em>int</em>) – Indexes of mesh.faces</p></li>
<li><p><strong>only_watertight</strong> (<em>bool</em>) – Only return submeshes which are watertight.</p></li>
<li><p><strong>append</strong> (<em>bool</em>) – Return a single mesh which has the faces appended,
if this flag is set, only_watertight is ignored</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>if append</strong> (<em>Trimesh object</em>)</p></li>
<li><p><em>else        list of Trimesh objects</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.tolist">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">tolist</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that any arrays or dicts passed containing
numpy arrays are properly converted to lists</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>any</em>) – Usually a dict with some numpy arrays as values</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – JSON- serializable version of data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.triangle_strips_to_faces">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">triangle_strips_to_faces</code><span class="sig-paren">(</span><em class="sig-param">strips</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.triangle_strips_to_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of triangle strips, convert them to (n,3) faces.</p>
<p>Processes all strips at once using np.concatenate and is significantly
faster than loop- based methods.</p>
<p>From the OpenGL programming guide describing a single triangle
strip [v0, v1, v2, v3, v4]:</p>
<p>Draws a series of triangles (three-sided polygons) using vertices
v0, v1, v2, then v2, v1, v3  (note the order), then v2, v3, v4,
and so on. The ordering is to ensure that the triangles are all
drawn with the same orientation so that the strip can correctly form
part of a surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>strips</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>list of</em><em> (</em><em>m</em><em>,</em><em>) </em><em>int vertex indices</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>faces</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m,3) int, vertex indices representing triangles</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.type_bases">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">type_bases</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">depth=4</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.type_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bases of the object passed.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.type_named">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">type_named</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.type_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to the type() builtin, but looks in class bases
for named instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>object to look for class of</em>) – </p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>name of class</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>named class, or None</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.unique_id">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">unique_id</code><span class="sig-paren">(</span><em class="sig-param">length=12</em>, <em class="sig-param">increment=0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.unique_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a decent looking alphanumeric unique identifier.
First 16 bits are time- incrementing, followed by randomness.</p>
<p>This function is used as a nicer looking alternative to:
&gt;&gt;&gt; uuid.uuid4().hex</p>
<p>Follows the advice in:
<a class="reference external" href="https://eager.io/blog/how-long-does-an-id-need-to-be/">https://eager.io/blog/how-long-does-an-id-need-to-be/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>int</em><em>, </em><em>length of resulting identifier</em>) – </p></li>
<li><p><strong>increment</strong> (<em>int</em><em>, </em><em>number to add to header uint16</em>) – useful if calling this function repeatedly
in a tight loop executing faster than time
can increment the header</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>unique</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str, unique alphanumeric identifier</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.unitize">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">unitize</code><span class="sig-paren">(</span><em class="sig-param">vectors</em>, <em class="sig-param">check_valid=False</em>, <em class="sig-param">threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.unitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitize a vector or an array or row- vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>(</em><em>n</em><em>,</em><em>m</em><em>) or </em><em>(</em><em>j</em><em>) </em><em>float</em>) – Vector or vectors to be unitized</p></li>
<li><p><strong>check_valid</strong> (<em>bool</em>) – If set, will return mask of nonzero vectors</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Cutoff for a value to be considered zero.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>unit</strong> (<em>(n,m) or (j) float</em>) – Input vectors but unitized</p></li>
<li><p><strong>valid</strong> (<em>(n,) bool or bool</em>) – Mask of nonzero vectors returned if <cite>check_valid</cite></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vector_hemisphere">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">vector_hemisphere</code><span class="sig-paren">(</span><em class="sig-param">vectors</em>, <em class="sig-param">return_sign=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vector_hemisphere" title="Permalink to this definition">¶</a></dt>
<dd><p>For a set of 3D vectors alter the sign so they are all in the
upper hemisphere.</p>
<p>If the vector lies on the plane all vectors with negative Y
will be reversed.</p>
<p>If the vector has a zero Z and Y value vectors with a
negative X value will be reversed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>(</em><em>n</em><em>,</em><em>3</em><em>) </em><em>float</em>) – Input vectors</p></li>
<li><p><strong>return_sign</strong> (<em>bool</em>) – Return the sign mask or not</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>oriented</strong> (<em>(n, 3) float</em>) – Vectors with same magnitude as source
but possibly reversed to ensure all vectors
are in the same hemisphere.</p></li>
<li><p><strong>sign</strong> (<em>(n,) float</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vector_to_spherical">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">vector_to_spherical</code><span class="sig-paren">(</span><em class="sig-param">cartesian</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vector_to_spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of cartesian points to (n,2) spherical unit
vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cartesian</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points in space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>spherical</strong> – Angles, in radians</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, 2) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vstack_empty">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">vstack_empty</code><span class="sig-paren">(</span><em class="sig-param">tup</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vstack_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>A thin wrapper for numpy.vstack that ignores empty lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tup</strong> (<em>tuple</em><em> or </em><em>list of arrays with the same number of columns</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>stacked</strong> – constituent arrays.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,d) array, with same number of columns as</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.wrap_as_stream">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">wrap_as_stream</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.wrap_as_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap a string or bytes object as a file object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>item</strong> (<em>str</em><em> or </em><em>bytes</em>) – Item to be wrapped</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wrapped</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>file-like object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.write_encoded">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">write_encoded</code><span class="sig-paren">(</span><em class="sig-param">file_obj</em>, <em class="sig-param">stuff</em>, <em class="sig-param">encoding='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.write_encoded" title="Permalink to this definition">¶</a></dt>
<dd><p>If a file is open in binary mode and a string is passed, encode and write
If a file is open in text   mode and bytes are passed, decode and write</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> (<em>file object</em><em>,  </em><em>with 'write' and 'mode'</em>) – </p></li>
<li><p><strong>stuff</strong> (<em>str</em><em> or </em><em>bytes</em><em>, </em><em>stuff to be written</em>) – </p></li>
<li><p><strong>encoding</strong> (<em>str</em><em>,          </em><em>encoding of text</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.zero_pad">
<code class="sig-prename descclassname">trimesh.util.</code><code class="sig-name descname">zero_pad</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">count</em>, <em class="sig-param">right=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.zero_pad" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>(</em><em>n</em><em>,</em><em>)</em>) – 1D array</p></li>
<li><p><strong>count</strong> (<em>int</em>) – Minimum length of result array</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>padded</strong> – 1D array where m &gt;= count</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(m,)</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.version">
<span id="trimesh-version-module"></span><h2>trimesh.version module<a class="headerlink" href="#module-trimesh.version" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-trimesh">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-trimesh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="https-github-com-mikedh-trimesh">
<h3><a class="reference external" href="https://github.com/mikedh/trimesh">https://github.com/mikedh/trimesh</a><a class="headerlink" href="#https-github-com-mikedh-trimesh" title="Permalink to this headline">¶</a></h3>
<p>Trimesh is a pure Python (2.7- 3.3+) library for loading and using triangular
meshes with an emphasis on watertight meshes. The goal of the library is to
provide a fully featured Trimesh object which allows for easy manipulation
and analysis, in the style of the Polygon object in the Shapely library.</p>
<dl class="class">
<dt id="trimesh.Trimesh">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">Trimesh</code><span class="sig-paren">(</span><em class="sig-param">vertices=None</em>, <em class="sig-param">faces=None</em>, <em class="sig-param">face_normals=None</em>, <em class="sig-param">vertex_normals=None</em>, <em class="sig-param">face_colors=None</em>, <em class="sig-param">vertex_colors=None</em>, <em class="sig-param">face_attributes=None</em>, <em class="sig-param">vertex_attributes=None</em>, <em class="sig-param">metadata=None</em>, <em class="sig-param">process=True</em>, <em class="sig-param">validate=False</em>, <em class="sig-param">use_embree=True</em>, <em class="sig-param">initial_cache=None</em>, <em class="sig-param">visual=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<dl class="method">
<dt id="trimesh.Trimesh.apply_obb">
<code class="sig-name descname">apply_obb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.apply_obb" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the oriented bounding box transform to the current mesh.</p>
<p>This will result in a mesh with an AABB centered at the
origin and the same dimensions as the OBB.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>matrix</strong> – Transformation matrix that was applied
to mesh to move it into OBB frame</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(4, 4) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.apply_transform">
<code class="sig-name descname">apply_transform</code><span class="sig-paren">(</span><em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mesh by a homogeneous transformation matrix.</p>
<p>Does the bookkeeping to avoid recomputing things so this function
should be used rather than directly modifying self.vertices
if possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Homogeneous transformation matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.area">
<em class="property">property </em><code class="sig-name descname">area</code><a class="headerlink" href="#trimesh.Trimesh.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Summed area of all triangles in the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area</strong> – Surface area of mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.area_faces">
<em class="property">property </em><code class="sig-name descname">area_faces</code><a class="headerlink" href="#trimesh.Trimesh.area_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The area of each face in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area_faces</strong> – Area of each face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.body_count">
<em class="property">property </em><code class="sig-name descname">body_count</code><a class="headerlink" href="#trimesh.Trimesh.body_count" title="Permalink to this definition">¶</a></dt>
<dd><p>How many connected groups of vertices exist in this mesh.</p>
<p>Note that this number may differ from result in mesh.split,
which is calculated from FACE rather than vertex adjacency.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>count</strong> – Number of connected vertex groups</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.bounds">
<em class="property">property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#trimesh.Trimesh.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the faces of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bounds</strong> – Bounding box with [min, max] coordinates</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.center_mass">
<em class="property">property </em><code class="sig-name descname">center_mass</code><a class="headerlink" href="#trimesh.Trimesh.center_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the center of mass/volume.</p>
<p>If the current mesh is not watertight, this is meaningless garbage
unless it was explicitly set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>center_mass</strong> – Volumetric center of mass of the mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.centroid">
<em class="property">property </em><code class="sig-name descname">centroid</code><a class="headerlink" href="#trimesh.Trimesh.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the average of the triangle centroids
weighted by the area of each triangle.</p>
<p>This will be valid even for non- watertight meshes,
unlike self.center_mass</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>centroid</strong> – The average vertex weighted by face area</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.compute_stable_poses">
<code class="sig-name descname">compute_stable_poses</code><span class="sig-paren">(</span><em class="sig-param">center_mass=None</em>, <em class="sig-param">sigma=0.0</em>, <em class="sig-param">n_samples=1</em>, <em class="sig-param">threshold=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.compute_stable_poses" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p>
<p>This method samples the location of the center of mass from a multivariate
gaussian (mean at com, cov equal to identity times sigma) over n_samples.
For each sample, it computes the stable resting poses of the mesh on a
a planar workspace and evaluates the probabilities of landing in
each pose if the object is dropped onto the table randomly.</p>
<p>This method returns the 4x4 homogeneous transform matrices that place
the shape against the planar surface with the z-axis pointing upwards
and a list of the probabilities for each pose.
The transforms and probabilties that are returned are sorted, with the
most probable pose first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center_mass</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – The object center of mass (if None, this method
assumes uniform density and watertightness and
computes a center of mass explicitly)</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – The covariance for the multivariate gaussian used
to sample center of mass locations</p></li>
<li><p><strong>n_samples</strong> (<em>int</em>) – The number of samples of the center of mass location</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The probability value at which to threshold
returned stable poses</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>transforms</strong> (<em>(n, 4, 4) float</em>) – The homogeneous matrices that transform the
object to rest in a stable pose, with the
new z-axis pointing upwards from the table
and the object just touching the table.</p></li>
<li><p><strong>probs</strong> (<em>(n,) float</em>) – A probability ranging from 0.0 to 1.0 for each pose</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.contains">
<code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, determine whether or not they are inside the mesh.
This raises an error if called on a non- watertight mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Points in cartesian space</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>contains</strong> – Whether or not each point is inside the mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n, ) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.convert_units">
<code class="sig-name descname">convert_units</code><span class="sig-paren">(</span><em class="sig-param">desired</em>, <em class="sig-param">guess=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.convert_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the units of the mesh into a specified unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>desired</strong> (<em>string</em>) – Units to convert to (eg ‘inches’)</p></li>
<li><p><strong>guess</strong> (<em>boolean</em>) – If self.units are not defined should we
guess the current units of the document and then convert?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.convex_decomposition">
<code class="sig-name descname">convex_decomposition</code><span class="sig-paren">(</span><em class="sig-param">maxhulls=20</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.convex_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate convex decomposition of a mesh.</p>
<p>testVHACD Parameters which can be passed as kwargs:</p>
<p>resolution                                  100000
max. concavity                              0.001
plane down-sampling                         4
convex-hull down-sampling                   4
alpha                                       0.05
beta                                        0.05
maxhulls                                    10
pca                                         0
mode                                        0
max. vertices per convex-hull               64
min. volume to add vertices to convex-hulls 0.0001
convex-hull approximation                   1
OpenCL acceleration                         1
OpenCL platform ID                          0
OpenCL device ID                            0
output                                      output.wrl
log                                         log.txt</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxhulls</strong> (<em>int</em>) – Maximum number of convex hulls to return</p></li>
<li><p><strong>**kwargs</strong> (<em>testVHACD keyword arguments</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>meshes</strong> – List of convex meshes that approximate the original</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of trimesh.Trimesh</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.convex_hull">
<em class="property">property </em><code class="sig-name descname">convex_hull</code><a class="headerlink" href="#trimesh.Trimesh.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Trimesh object representing the convex hull of
the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>convex</strong> – Mesh of convex hull of current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely get a copy of the current mesh.</p>
<p>Copied objects will have emptied caches to avoid memory
issues and so may be slow on initial operations until
caches are regenerated.</p>
<p>Current object will <em>not</em> have its cache cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>copied</strong> – Copy of current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.crc">
<code class="sig-name descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A zlib.adler32 checksum for the current mesh data.</p>
<p>This is about 5x faster than an MD5, and the checksum is
checked every time something is requested from the cache so
it gets called a lot.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>crc</strong> – Checksum of current mesh data</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.density">
<em class="property">property </em><code class="sig-name descname">density</code><a class="headerlink" href="#trimesh.Trimesh.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The density of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>density</strong> – The density of the mesh.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.difference">
<code class="sig-name descname">difference</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean difference between this mesh and n other meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, or </em><em>list of trimesh.Trimesh objects</em>) – Meshes to difference</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>difference</strong> – Difference between self and other Trimesh objects</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.edges">
<em class="property">property </em><code class="sig-name descname">edges</code><a class="headerlink" href="#trimesh.Trimesh.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges of the mesh (derived from faces).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges</strong> – List of vertex indices making up edges</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.edges_face">
<em class="property">property </em><code class="sig-name descname">edges_face</code><a class="headerlink" href="#trimesh.Trimesh.edges_face" title="Permalink to this definition">¶</a></dt>
<dd><p>Which face does each edge belong to.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_face</strong> – Index of self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.edges_sorted">
<em class="property">property </em><code class="sig-name descname">edges_sorted</code><a class="headerlink" href="#trimesh.Trimesh.edges_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges sorted along axis 1</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_sorted</strong> – Same as self.edges but sorted along axis 1</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.edges_sparse">
<em class="property">property </em><code class="sig-name descname">edges_sparse</code><a class="headerlink" href="#trimesh.Trimesh.edges_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges in sparse bool COO graph format where connected
vertices are True.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sparse</strong> – Sparse graph in COO format</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), len(self.vertices)) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.edges_unique">
<em class="property">property </em><code class="sig-name descname">edges_unique</code><a class="headerlink" href="#trimesh.Trimesh.edges_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique edges of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_unique</strong> – Vertex indices for unique edges</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.edges_unique_inverse">
<em class="property">property </em><code class="sig-name descname">edges_unique_inverse</code><a class="headerlink" href="#trimesh.Trimesh.edges_unique_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse required to reproduce
self.edges_sorted from self.edges_unique.</p>
<p>Useful for referencing edge properties:
mesh.edges_unique[mesh.edges_unique_inverse] == m.edges_sorted</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>inverse</strong> – Indexes of self.edges_unique</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.edges),) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.edges_unique_length">
<em class="property">property </em><code class="sig-name descname">edges_unique_length</code><a class="headerlink" href="#trimesh.Trimesh.edges_unique_length" title="Permalink to this definition">¶</a></dt>
<dd><p>How long is each unique edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>length</strong> – Length of each unique edge</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.edges_unique), ) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.euler_number">
<em class="property">property </em><code class="sig-name descname">euler_number</code><a class="headerlink" href="#trimesh.Trimesh.euler_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euler characteristic (a topological invariant) for the mesh
In order to guarantee correctness, this should be called after
remove_unreferenced_vertices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>euler_number</strong> – Topological invariant</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.eval_cached">
<code class="sig-name descname">eval_cached</code><span class="sig-paren">(</span><em class="sig-param">statement</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.eval_cached" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a statement and cache the result before returning.</p>
<p>Statements are evaluated inside the Trimesh object, and</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>statement</strong> (<em>str</em>) – Statement of valid python code</p></li>
<li><p><strong>*args</strong> (<em>list</em>) – Available inside statement as args[0], etc</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>result of running eval on statement with args</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>r = mesh.eval_cached(‘np.dot(self.vertices, args[0])’, [0,0,1])</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.export">
<code class="sig-name descname">export</code><span class="sig-paren">(</span><em class="sig-param">file_obj=None</em>, <em class="sig-param">file_type=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the current mesh to a file object.
If file_obj is a filename, file will be written there.</p>
<p>Supported formats are stl, off, ply, collada, json, dict, glb,
dict64, msgpack.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> (<em>open writeable file object</em>) – str, file name where to save the mesh
None, if you would like this function to return the export blob</p></li>
<li><p><strong>file_type</strong> (<em>str</em>) – Which file type to export as.
If file name is passed this is not required</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.extents">
<em class="property">property </em><code class="sig-name descname">extents</code><a class="headerlink" href="#trimesh.Trimesh.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The length, width, and height of the bounding box of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>extents</strong> – Array containing axis aligned [length, width, height]</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency">
<em class="property">property </em><code class="sig-name descname">face_adjacency</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>adjacency</strong> – Pairs of faces which share an edge</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,2) int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: mesh = trimesh.load(‘models/featuretype.STL’)</p>
<p>In [2]: mesh.face_adjacency
Out[2]:
array([[   0,    1],</p>
<blockquote>
<div><p>[   2,    3],
[   0,    3],
…,
[1112,  949],
[3467, 3475],
[1113, 3475]])</p>
</div></blockquote>
<p>In [3]: mesh.faces[mesh.face_adjacency[0]]
Out[3]:
TrackedArray([[   1,    0,  408],</p>
<blockquote>
<div><p>[1239,    0,    1]], dtype=int64)</p>
</div></blockquote>
<p>In [4]: import networkx as nx</p>
<p>In [5]: graph = nx.from_edgelist(mesh.face_adjacency)</p>
<p>In [6]: groups = nx.connected_components(graph)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_angles">
<em class="property">property </em><code class="sig-name descname">face_adjacency_angles</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle between adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>adjacency_angle</strong> – Angle between adjacent faces
Each value corresponds with self.face_adjacency</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_convex">
<em class="property">property </em><code class="sig-name descname">face_adjacency_convex</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return faces which are adjacent and locally convex.</p>
<p>What this means is that given faces A and B, the one vertex
in B that is not shared with A, projected onto the plane of A
has a projection that is zero or negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>are_convex</strong> – Face pairs that are locally convex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_edges">
<em class="property">property </em><code class="sig-name descname">face_adjacency_edges</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the edges that are shared by the adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges</strong> – Vertex indices which correspond to face_adjacency</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_projections">
<em class="property">property </em><code class="sig-name descname">face_adjacency_projections</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection of the non- shared vertex of a triangle onto
its adjacent face</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>projections</strong> – Dot product of vertex
onto plane of adjacent triangle.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_radius">
<em class="property">property </em><code class="sig-name descname">face_adjacency_radius</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>radii</strong> – Approximate radius formed by triangle pair</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_span">
<em class="property">property </em><code class="sig-name descname">face_adjacency_span</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_span" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate perpendicular projection of the non- shared
vertices in a pair of adjacent faces onto the shared edge of
the two faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>span</strong> – Approximate span between the non- shared vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.face_adjacency),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_tree">
<em class="property">property </em><code class="sig-name descname">face_adjacency_tree</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree of face adjacencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tree</strong> – Where each edge in self.face_adjacency has a
rectangular cell</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rtree.index</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_adjacency_unshared">
<em class="property">property </em><code class="sig-name descname">face_adjacency_unshared</code><a class="headerlink" href="#trimesh.Trimesh.face_adjacency_unshared" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex index of the two vertices not in the shared
edge between two adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vid_unshared</strong> – Indexes of mesh.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(mesh.face_adjacency), 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_angles">
<em class="property">property </em><code class="sig-name descname">face_angles</code><a class="headerlink" href="#trimesh.Trimesh.face_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angle at each vertex of a face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>angles</strong> – Angle at each vertex of a face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_angles_sparse">
<em class="property">property </em><code class="sig-name descname">face_angles_sparse</code><a class="headerlink" href="#trimesh.Trimesh.face_angles_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the face angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sparse</strong> – dtype: float
shape: (len(self.vertices), len(self.faces))</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.sparse.coo_matrix with:</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.face_normals">
<em class="property">property </em><code class="sig-name descname">face_normals</code><a class="headerlink" href="#trimesh.Trimesh.face_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unit normal vector for each face.</p>
<p>If a face is degenerate and a normal can’t be generated
a zero magnitude unit vector will be returned for that face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>normals</strong> – Normal vectors of each face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.faces), 3) np.float64</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.faces">
<em class="property">property </em><code class="sig-name descname">faces</code><a class="headerlink" href="#trimesh.Trimesh.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The faces of the mesh.</p>
<p>This is regarded as core information which cannot be regenerated from
cache, and as such is stored in self._data which tracks the array for
changes and clears cached values of the mesh if this is altered.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>faces</strong> – Representing triangles which reference self.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,3) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.faces_sparse">
<em class="property">property </em><code class="sig-name descname">faces_sparse</code><a class="headerlink" href="#trimesh.Trimesh.faces_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sparse</strong> – Has properties:
dtype : bool
shape : (len(self.vertices), len(self.faces))</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.sparse.coo_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.faces_unique_edges">
<em class="property">property </em><code class="sig-name descname">faces_unique_edges</code><a class="headerlink" href="#trimesh.Trimesh.faces_unique_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>For each face return which indexes in mesh.unique_edges constructs
that face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>faces_unique_edges</strong> – Indexes of self.edges_unique that
construct self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.faces), 3) int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [0]: mesh.faces[0:2]
Out[0]:
TrackedArray([[    1,  6946, 24224],</p>
<blockquote>
<div><p>[ 6946,  1727, 24225]])</p>
</div></blockquote>
<p>In [1]: mesh.edges_unique[mesh.faces_unique_edges[0:2]]
Out[1]:
array([[[    1,  6946],</p>
<blockquote>
<div><blockquote>
<div><p>[ 6946, 24224],
[    1, 24224]],</p>
</div></blockquote>
<dl class="simple">
<dt>[[ 1727,  6946],</dt><dd><p>[ 1727, 24225],
[ 6946, 24225]]])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.facets">
<em class="property">property </em><code class="sig-name descname">facets</code><a class="headerlink" href="#trimesh.Trimesh.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of face indices for coplanar adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>facets</strong> – Groups of indexes of self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, ) sequence of (m,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.facets_area">
<em class="property">property </em><code class="sig-name descname">facets_area</code><a class="headerlink" href="#trimesh.Trimesh.facets_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array containing the area of each facet.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>area</strong> – Total area of each facet (group of faces)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.facets),) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.facets_boundary">
<em class="property">property </em><code class="sig-name descname">facets_boundary</code><a class="headerlink" href="#trimesh.Trimesh.facets_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edges which represent the boundary of each facet</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>edges_boundary</strong> – Indices of self.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>sequence of (n, 2) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.facets_normal">
<em class="property">property </em><code class="sig-name descname">facets_normal</code><a class="headerlink" href="#trimesh.Trimesh.facets_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normal of each facet</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>normals</strong> – A unit normal vector for each facet</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.facets), 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.facets_on_hull">
<em class="property">property </em><code class="sig-name descname">facets_on_hull</code><a class="headerlink" href="#trimesh.Trimesh.facets_on_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Find which facets of the mesh are on the convex hull.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>on_hull</strong> – is A facet on the meshes convex hull or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(mesh.facets),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.facets_origin">
<em class="property">property </em><code class="sig-name descname">facets_origin</code><a class="headerlink" href="#trimesh.Trimesh.facets_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a point on the facet plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>origins</strong> – A point on each facet plane</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.facets), 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.fill_holes">
<code class="sig-name descname">fill_holes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill single triangle and single quad holes in the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>watertight</strong> – Is the mesh watertight after the function completes</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.fix_normals">
<code class="sig-name descname">fix_normals</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and fix problems with self.face_normals and self.faces
winding direction.</p>
<p>For face normals ensure that vectors are consistently pointed
outwards, and that self.faces is wound in the correct direction
for all connected components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>multibody</strong> (<em>None</em><em> or </em><em>bool</em>) – Fix normals across multiple bodies
if None automatically pick from body_count</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.identifier">
<em class="property">property </em><code class="sig-name descname">identifier</code><a class="headerlink" href="#trimesh.Trimesh.identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a float vector which is unique to the mesh
and is robust to rotation and translation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>identifier</strong> – Identifying properties of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(6,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.identifier_md5">
<em class="property">property </em><code class="sig-name descname">identifier_md5</code><a class="headerlink" href="#trimesh.Trimesh.identifier_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the rotation invariant identifier vector</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>hashed</strong> – MD5 hash of the identifier vector</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean intersection between this mesh and n other meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, or </em><em>list of trimesh.Trimesh objects</em>) – Meshes to calculate intersections with</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intersection</strong> – Mesh of the volume contained by all passed meshes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.invert">
<code class="sig-name descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the mesh in- place by reversing the winding of every
face and negating normals without dumping the cache.</p>
<p>self.faces :          columns reversed
self.face_normals :   negated if defined
self.vertex_normals : negated if defined</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.is_convex">
<em class="property">property </em><code class="sig-name descname">is_convex</code><a class="headerlink" href="#trimesh.Trimesh.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is convex or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>is_convex</strong> – Is mesh convex or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.is_empty">
<em class="property">property </em><code class="sig-name descname">is_empty</code><a class="headerlink" href="#trimesh.Trimesh.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the current mesh have data defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>empty</strong> – If True, no data is set on the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.is_volume">
<em class="property">property </em><code class="sig-name descname">is_volume</code><a class="headerlink" href="#trimesh.Trimesh.is_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh has all the properties required to represent
a valid volume, rather than just a surface.</p>
<p>These properties include being watertight, having consistent
winding and outward facing normals.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>valid</strong> – Does the mesh represent a volume</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.is_watertight">
<em class="property">property </em><code class="sig-name descname">is_watertight</code><a class="headerlink" href="#trimesh.Trimesh.is_watertight" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is watertight by making sure every edge is
included in two faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>is_watertight</strong> – Is mesh watertight or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.is_winding_consistent">
<em class="property">property </em><code class="sig-name descname">is_winding_consistent</code><a class="headerlink" href="#trimesh.Trimesh.is_winding_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the mesh have consistent winding or not.
A mesh with consistent winding has each shared edge
going in an opposite direction from the other in the pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>consistent</strong> – Is winding is consistent or not</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.kdtree">
<em class="property">property </em><code class="sig-name descname">kdtree</code><a class="headerlink" href="#trimesh.Trimesh.kdtree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.
Not cached as this lead to observed memory issues and segfaults.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tree</strong> – Contains mesh.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scipy.spatial.cKDTree</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.mass">
<em class="property">property </em><code class="sig-name descname">mass</code><a class="headerlink" href="#trimesh.Trimesh.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass of the current mesh, based on specified density and
volume. If the current mesh isn’t watertight this is garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>mass</strong> – Mass of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.mass_properties">
<em class="property">property </em><code class="sig-name descname">mass_properties</code><a class="headerlink" href="#trimesh.Trimesh.mass_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mass properties of the current mesh.</p>
<p>Assumes uniform density, and result is probably garbage if mesh
isn’t watertight.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><strong>properties</strong> – With keys:
‘volume’      : in global units^3
‘mass’        : From specified density
‘density’     : Included again for convenience (same as kwarg density)
‘inertia’     : Taken at the center of mass and aligned with global</p>
<blockquote>
<div><p>coordinate system</p>
</div></blockquote>
<p>’center_mass’ : Center of mass location, in global coordinate system</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.md5">
<code class="sig-name descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the core geometry information for the mesh,
faces and vertices.</p>
<p>Generated from TrackedArray which subclasses np.ndarray to
monitor array for changes and returns a correct lazily
evaluated md5 so it only has to recalculate the hash
occasionally, rather than on every call.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>md5</strong> – MD5 of everything in the DataStore</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.merge_vertices">
<code class="sig-name descname">merge_vertices</code><span class="sig-paren">(</span><em class="sig-param">digits=None</em>, <em class="sig-param">textured=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has vertices that are closer than
trimesh.constants.tol.merge reindex faces to reference
the same index for both vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>digits</strong> (<em>int</em>) – If specified overrides tol.merge</p></li>
<li><p><strong>textured</strong> (<em>bool</em>) – If True avoids merging vertices with different UV
coordinates. No effect on untextured meshes.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.moment_inertia">
<em class="property">property </em><code class="sig-name descname">moment_inertia</code><a class="headerlink" href="#trimesh.Trimesh.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the moment of inertia matrix of the current mesh.
If mesh isn’t watertight this is garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>inertia</strong> – Moment of inertia of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.outline">
<code class="sig-name descname">outline</code><span class="sig-paren">(</span><em class="sig-param">face_ids=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of face indexes find the outline of those
faces and return it as a Path3D.</p>
<p>The outline is defined here as every edge which is only
included by a single triangle.</p>
<p>Note that this implies a non-watertight mesh as the
outline of a watertight mesh is an empty path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>face_ids</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>int</em>) – Indices to compute the outline of.
If None, outline of full mesh will be computed.</p></li>
<li><p><strong>**kwargs</strong> (<em>passed to Path3D constructor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>path</strong> – Curve in 3D of the outline</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path3D" title="trimesh.path.path.Path3D">Path3D</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.principal_inertia_components">
<em class="property">property </em><code class="sig-name descname">principal_inertia_components</code><a class="headerlink" href="#trimesh.Trimesh.principal_inertia_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal components of inertia</p>
<p>Ordering corresponds to mesh.principal_inertia_vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>components</strong> – Principal components of inertia</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.principal_inertia_transform">
<em class="property">property </em><code class="sig-name descname">principal_inertia_transform</code><a class="headerlink" href="#trimesh.Trimesh.principal_inertia_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A transform which moves the current mesh so the principal
inertia vectors are on the X,Y, and Z axis, and the centroid is
at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>transform</strong> – Homogeneous transformation matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(4, 4) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.principal_inertia_vectors">
<em class="property">property </em><code class="sig-name descname">principal_inertia_vectors</code><a class="headerlink" href="#trimesh.Trimesh.principal_inertia_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal axis of inertia.</p>
<p>Ordering corresponds to mesh.principal_inertia_components</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vectors</strong> – Three vectors pointing along the
principal axis of inertia directions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.process">
<code class="sig-name descname">process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the bare minimum processing to make a mesh useful.</p>
<dl class="simple">
<dt>Does this by:</dt><dd><ol class="arabic simple">
<li><p>removing NaN and Inf values</p></li>
<li><p>merging duplicate vertices</p></li>
</ol>
</dd>
<dt>If self._validate:</dt><dd><ol class="arabic simple" start="3">
<li><p>Remove triangles which have one edge of their rectangular 2D
oriented bounding box shorter than tol.merge</p></li>
<li><p>remove duplicated triangles</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>self</strong> – Current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.referenced_vertices">
<em class="property">property </em><code class="sig-name descname">referenced_vertices</code><a class="headerlink" href="#trimesh.Trimesh.referenced_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Which vertices in the current mesh are referenced by a face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>referenced</strong> – Which vertices are referenced by a face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.register">
<code class="sig-name descname">register</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a mesh with another mesh or a PointCloud using
the principal axes of inertia as a starting point which
is refined by iterative closest point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>trimesh.Trimesh object</em>) – Mesh to align with other</p></li>
<li><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em> or </em><em>(</em><em>n</em><em>, </em><em>3</em><em>) </em><em>float</em>) – Mesh or points in space</p></li>
<li><p><strong>samples</strong> (<em>int</em>) – Number of samples from mesh surface to align</p></li>
<li><p><strong>icp_first</strong> (<em>int</em>) – How many ICP iterations for the 9 possible
combinations of</p></li>
<li><p><strong>icp_final</strong> (<em>int</em>) – How many ICP itertations for the closest
candidate from the wider search</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mesh_to_other</strong> (<em>(4, 4) float</em>) – Transform to align mesh to the other object</p></li>
<li><p><strong>cost</strong> (<em>float</em>) – Average square distance per point</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.remove_degenerate_faces">
<code class="sig-name descname">remove_degenerate_faces</code><span class="sig-paren">(</span><em class="sig-param">height=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.remove_degenerate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove degenerate faces (faces without 3 unique vertex indices)
from the current mesh.</p>
<p>If a height is specified, it will remove any face with a 2D oriented
bounding box with one edge shorter than that height.</p>
<p>If not specified, it will remove any face with a zero normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>height</strong> (<em>float</em>) – If specified removes faces with an oriented bounding
box shorter than this on one side.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nondegenerate</strong> – Mask used to remove faces</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(len(self.faces),) bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.remove_duplicate_faces">
<code class="sig-name descname">remove_duplicate_faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.remove_duplicate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>On the current mesh remove any faces which are duplicates.</p>
<p>self.faces : removes duplicates</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.remove_infinite_values">
<code class="sig-name descname">remove_infinite_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.remove_infinite_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that every vertex and face consists of finite numbers.</p>
<p>This will remove vertices or faces containing np.nan and np.inf</p>
<p>self.faces : masked to remove np.inf/np.nan
self.vertices : masked to remove np.inf/np.nan</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.remove_unreferenced_vertices">
<code class="sig-name descname">remove_unreferenced_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.remove_unreferenced_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all vertices in the current mesh which are not
referenced by a face.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.rezero">
<code class="sig-name descname">rezero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.rezero" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the mesh so that all vertex vertices are positive.</p>
<p>self.vertices : Translated to first octant (all values &gt; 0)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">count</em>, <em class="sig-param">return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples distributed normally across the
surface of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>count</strong> (<em>int</em>) – Number of points to sample</p></li>
<li><p><strong>return_index</strong> (<em>bool</em>) – If True will also return the index of which face each
sample was taken from.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>samples</strong> (<em>(count, 3) float</em>) – Points on surface of mesh</p></li>
<li><p><strong>face_index</strong> (<em>(count, ) int</em>) – Index of self.faces</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#trimesh.Trimesh.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>A metric for the overall scale of the mesh, the length of the
diagonal of the axis aligned bounding box of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scale</strong> – The length of the meshes AABB diagonal</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.scene">
<code class="sig-name descname">scene</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Scene object containing the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scene</strong> – Contains just the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="trimesh.scene.html#trimesh.scene.scene.Scene" title="trimesh.scene.scene.Scene">trimesh.scene.scene.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.section">
<code class="sig-name descname">section</code><span class="sig-paren">(</span><em class="sig-param">plane_normal</em>, <em class="sig-param">plane_origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3D cross section of the current mesh and a plane
defined by origin and normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_normal</strong> – Normal vector of section plane</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on the cross section plane</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>intersections</strong> – Curve of intersection</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path3D" title="trimesh.path.path.Path3D">Path3D</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.section_multiplane">
<code class="sig-name descname">section_multiplane</code><span class="sig-paren">(</span><em class="sig-param">plane_origin</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">heights</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.section_multiplane" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multiple parallel cross sections of the current
mesh in 2D.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_normal</strong> – Normal vector of section plane</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on the cross section plane</p></li>
<li><p><strong>heights</strong> (<em>(</em><em>n</em><em>,</em><em>) </em><em>float</em>) – Each section is offset by height along
the plane normal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>paths</strong> – 2D cross sections at specified heights.
path.metadata[‘to_3D’] contains transform
to return 2D section back into 3D space.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) <a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path2D" title="trimesh.path.path.Path2D">Path2D</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the mesh in an opengl window. Requires pyglet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>smooth</strong> (<em>bool</em>) – Run smooth shading on mesh or not,
large meshes will be slow</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>scene</strong> – Scene with current mesh in it</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>trimesh.scene.Scene</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.slice_plane">
<code class="sig-name descname">slice_plane</code><span class="sig-paren">(</span><em class="sig-param">plane_origin</em>, <em class="sig-param">plane_normal</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.slice_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns another mesh that is the current mesh
sliced by the plane defined by origin and normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_normal</strong> – Normal vector of slicing plane</p></li>
<li><p><strong>plane_origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point on the slicing plane</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>new_mesh</strong> – Subset of current mesh sliced by plane</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.smoothed">
<code class="sig-name descname">smoothed</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of the current mesh which will render
nicely, without changing source mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>angle</strong> (<em>float</em>) – Angle in radians, face pairs with angles smaller than
this value will appear smoothed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>smoothed</strong> – Non watertight version of current mesh
which will render nicely with smooth shading</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Trimesh objects, based on face connectivity.
Splits into individual components, sometimes referred to as ‘bodies’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>only_watertight</strong> (<em>bool</em>) – Only return watertight meshes and discard remainder</p></li>
<li><p><strong>adjacency</strong> (<em>None</em><em> or </em><em>(</em><em>n</em><em>, </em><em>2</em><em>) </em><em>int</em>) – Override face adjacency with custom values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>meshes</strong> – Separate bodies from original mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,) <a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.subdivide">
<code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">face_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh, with each subdivided face replaced with four
smaller faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>face_index</strong> (<em>(</em><em>m</em><em>,</em><em>) </em><em>int</em><em> or </em><em>None</em>) – If None all faces of mesh will be subdivided
If (m,) int array of indices: only specified faces will be
subdivided. Note that in this case the mesh will generally
no longer be manifold, as the additional vertex on the midpoint
will not be used by the adjacent faces to the faces specified,
and an additional postprocessing step will be required to
make resulting mesh watertight</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.submesh">
<code class="sig-name descname">submesh</code><span class="sig-paren">(</span><em class="sig-param">faces_sequence</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.submesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>faces_sequence</strong> (<em>sequence</em><em> (</em><em>m</em><em>,</em><em>) </em><em>int</em>) – Face indices of mesh</p></li>
<li><p><strong>only_watertight</strong> (<em>bool</em>) – Only return submeshes which are watertight</p></li>
<li><p><strong>append</strong> (<em>bool</em>) – Return a single mesh which has the faces appended.
if this flag is set, only_watertight is ignored</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>if append</strong> (<em>trimesh.Trimesh object</em>)</p></li>
<li><p><strong>else</strong> (<em>list of trimesh.Trimesh objects</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.symmetry">
<em class="property">property </em><code class="sig-name descname">symmetry</code><a class="headerlink" href="#trimesh.Trimesh.symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a mesh has rotational symmetry.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>symmetry</strong> – ‘radial’     Symmetric around an axis
‘spherical’  Symmetric around a point</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None         No rotational symmetry</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.symmetry_axis">
<em class="property">property </em><code class="sig-name descname">symmetry_axis</code><a class="headerlink" href="#trimesh.Trimesh.symmetry_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>axis</strong> – Axis around which a 2D profile
was revolved to generate this mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.symmetry_section">
<em class="property">property </em><code class="sig-name descname">symmetry_section</code><a class="headerlink" href="#trimesh.Trimesh.symmetry_section" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the two
vectors which make up a section coordinate frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>section</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float, vectors to take a section along</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.to_dict">
<code class="sig-name descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the current mesh, with keys
that can be used as the kwargs for the Trimesh constructor, eg:</p>
<p>a = Trimesh(<a href="#id27"><span class="problematic" id="id28">**</span></a>other_mesh.to_dict())</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>result</strong> – With keys that match trimesh constructor</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.triangles">
<em class="property">property </em><code class="sig-name descname">triangles</code><a class="headerlink" href="#trimesh.Trimesh.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Actual triangles of the mesh (points, not indexes)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>triangles</strong> – Points of triangle vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.triangles_center">
<em class="property">property </em><code class="sig-name descname">triangles_center</code><a class="headerlink" href="#trimesh.Trimesh.triangles_center" title="Permalink to this definition">¶</a></dt>
<dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>triangles_center</strong> – Center of each triangular face</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.faces), 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.triangles_cross">
<em class="property">property </em><code class="sig-name descname">triangles_cross</code><a class="headerlink" href="#trimesh.Trimesh.triangles_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>The cross product of two edges of each triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>crosses</strong> – Cross product of each triangle</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.triangles_tree">
<em class="property">property </em><code class="sig-name descname">triangles_tree</code><a class="headerlink" href="#trimesh.Trimesh.triangles_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree containing each face of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tree</strong> – Each triangle in self.faces has a rectangular cell</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>rtree.index</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.union">
<code class="sig-name descname">union</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean union between this mesh and n other meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh"><em>trimesh.Trimesh</em></a><em>, or </em><em>list of trimesh.Trimesh objects</em>) – Other meshes to union</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong> – Union of self and other Trimesh objects</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.units">
<em class="property">property </em><code class="sig-name descname">units</code><a class="headerlink" href="#trimesh.Trimesh.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of units for the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>units</strong> – Unit system mesh is in, or None if not defined</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.unmerge_vertices">
<code class="sig-name descname">unmerge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.unmerge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all face references so that every face contains
three unique vertex indices and no faces are adjacent.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.update_faces">
<code class="sig-name descname">update_faces</code><span class="sig-paren">(</span><em class="sig-param">mask</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.update_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>In many cases, we will want to remove specific faces.
However, there is additional bookkeeping to do this cleanly.
This function updates the set of faces with a validity mask,
as well as keeping track of normals and colors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>valid</strong> – Mask to remove faces</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.update_vertices">
<code class="sig-name descname">update_vertices</code><span class="sig-paren">(</span><em class="sig-param">mask</em>, <em class="sig-param">inverse=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.update_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vertices with a mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertex_mask</strong> (<em>(</em><em>len</em><em>(</em><em>self.vertices</em><em>)</em><em>) </em><em>bool</em>) – Array of which vertices to keep</p></li>
<li><p><strong>inverse</strong> (<em>(</em><em>len</em><em>(</em><em>self.vertices</em><em>)</em><em>) </em><em>int</em>) – Array to reconstruct vertex references
such as output by np.unique</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.vertex_adjacency_graph">
<em class="property">property </em><code class="sig-name descname">vertex_adjacency_graph</code><a class="headerlink" href="#trimesh.Trimesh.vertex_adjacency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a networkx graph representing the vertices and their connections
in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>graph</strong> – Graph representing vertices and edges between
them where vertices are nodes and edges are edges</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>networkx.Graph</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<p>mesh = trimesh.primitives.Box()
graph = mesh.vertex_adjacency_graph
graph.neighbors(0)
&gt; [1,2,3,4]</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.vertex_defects">
<em class="property">property </em><code class="sig-name descname">vertex_defects</code><a class="headerlink" href="#trimesh.Trimesh.vertex_defects" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles
of every face that includes that vertex.</p>
<p>If a vertex is only included by coplanar triangles, this
will be zero. For convex regions this is positive, and
concave negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_defect</strong> – Vertex defect at the every vertex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), ) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.vertex_degree">
<em class="property">property </em><code class="sig-name descname">vertex_degree</code><a class="headerlink" href="#trimesh.Trimesh.vertex_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of faces each vertex is included in.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>degree</strong> – Number of faces each vertex is included in</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), ) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.vertex_faces">
<em class="property">property </em><code class="sig-name descname">vertex_faces</code><a class="headerlink" href="#trimesh.Trimesh.vertex_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>A representation of the face indices that correspond to each vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_faces</strong> – Each row contains the face indices that correspond to the given vertex,
padded with -1 up to the max number of faces corresponding to any one vertex
Where n == len(self.vertices), m == max number of faces for a single vertex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,m) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.vertex_neighbors">
<em class="property">property </em><code class="sig-name descname">vertex_neighbors</code><a class="headerlink" href="#trimesh.Trimesh.vertex_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex neighbors of each vertex of the mesh, determined from
the cached vertex_adjacency_graph, if already existent.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_neighbors</strong> – Represents immediate neighbors of each vertex along
the edge of a triangle</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices),) int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">Box</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1,2,3,4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.vertex_normals">
<em class="property">property </em><code class="sig-name descname">vertex_normals</code><a class="headerlink" href="#trimesh.Trimesh.vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex normals of the mesh. If the normals were loaded
we check to make sure we have the same number of vertex
normals and vertices before returning them. If there are
no vertex normals defined or a shape mismatch we  calculate
the vertex normals from the mean normals of the faces the
vertex is used in.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertex_normals</strong> – Represents the surface normal at each vertex.
Where n == len(self.vertices)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.vertices">
<em class="property">property </em><code class="sig-name descname">vertices</code><a class="headerlink" href="#trimesh.Trimesh.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertices of the mesh.</p>
<p>This is regarded as core information which cannot be
generated from cache and as such is stored in self._data
which tracks the array for changes and clears cached
values of the mesh if this is altered.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertices</strong> – Points in cartesian space referenced by self.faces</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.visual">
<em class="property">property </em><code class="sig-name descname">visual</code><a class="headerlink" href="#trimesh.Trimesh.visual" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the stored visuals for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>visual</strong> – Contains visual information about the mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="trimesh.visual.html#trimesh.visual.color.ColorVisuals" title="trimesh.visual.color.ColorVisuals">ColorVisuals</a> or <a class="reference internal" href="trimesh.visual.html#trimesh.visual.texture.TextureVisuals" title="trimesh.visual.texture.TextureVisuals">TextureVisuals</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.volume">
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#trimesh.Trimesh.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the current mesh calculated using a surface
integral. If the current mesh isn’t watertight this is
garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>volume</strong> – Volume of the current mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Trimesh.voxelized">
<code class="sig-name descname">voxelized</code><span class="sig-paren">(</span><em class="sig-param">pitch</em>, <em class="sig-param">method='subdivide'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Trimesh.voxelized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a VoxelGrid object representing the current mesh
discretized into voxels at the specified pitch</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pitch</strong> (<em>float</em>) – The edge length of a single voxel</p></li>
<li><p><strong>method</strong> (implementation key. See <cite>trimesh.voxel.creation.voxelizers</cite>) – </p></li>
<li><p><strong>**kwargs</strong> (<em>additional kwargs passed to the specified implementation.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>voxelized</strong> – Representing the current mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>VoxelGrid object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.PointCloud">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">PointCloud</code><span class="sig-paren">(</span><em class="sig-param">vertices</em>, <em class="sig-param">colors=None</em>, <em class="sig-param">color=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.PointCloud" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<p>Hold 3D points in an object which can be visualized
in a scene.</p>
<dl class="method">
<dt id="trimesh.PointCloud.apply_transform">
<code class="sig-name descname">apply_transform</code><span class="sig-paren">(</span><em class="sig-param">transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.PointCloud.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a homogeneous transformation to the PointCloud
object in- place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transform</strong> (<em>(</em><em>4</em><em>, </em><em>4</em><em>) </em><em>float</em>) – Homogeneous transformation to apply to PointCloud</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.bounds">
<em class="property">property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#trimesh.PointCloud.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bounds</strong> – Miniumum, Maximum verteex</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2, 3) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.centroid">
<em class="property">property </em><code class="sig-name descname">centroid</code><a class="headerlink" href="#trimesh.PointCloud.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean vertex position</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>centroid</strong> – Mean vertex position</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.colors">
<em class="property">property </em><code class="sig-name descname">colors</code><a class="headerlink" href="#trimesh.PointCloud.colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Stored per- point color</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>colors</strong> – Per- point RGBA color</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.vertices), 4) np.uint8</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.convex_hull">
<em class="property">property </em><code class="sig-name descname">convex_hull</code><a class="headerlink" href="#trimesh.PointCloud.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>A convex hull of every point.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>convex_hull</strong> – A watertight mesh of the hull of the points</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.PointCloud.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely get a copy of the current point cloud.</p>
<p>Copied objects will have emptied caches to avoid memory
issues and so may be slow on initial operations until
caches are regenerated.</p>
<p>Current object will <em>not</em> have its cache cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>copied</strong> – Copy of current point cloud</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.PointCloud" title="trimesh.PointCloud">trimesh.PointCloud</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.extents">
<em class="property">property </em><code class="sig-name descname">extents</code><a class="headerlink" href="#trimesh.PointCloud.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the axis aligned bounds</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>extents</strong> – Edge length of axis aligned bounding box</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.is_empty">
<em class="property">property </em><code class="sig-name descname">is_empty</code><a class="headerlink" href="#trimesh.PointCloud.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Are there any vertices defined or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>empty</strong> – True if no vertices defined</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.md5">
<code class="sig-name descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.PointCloud.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an MD5 hash of the current vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>md5</strong> – Hash of self.vertices</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.merge_vertices">
<code class="sig-name descname">merge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.PointCloud.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge vertices closer than tol.merge (default: 1e-8)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.scene">
<code class="sig-name descname">scene</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.PointCloud.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>A scene containing just the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scene</strong> – Scene object containing this PointCloud</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene">trimesh.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#trimesh.PointCloud.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of the pointcloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>shape</strong> – Shape of vertex array</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2,) int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.PointCloud.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a viewer window displaying the current PointCloud</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.PointCloud.vertices">
<em class="property">property </em><code class="sig-name descname">vertices</code><a class="headerlink" href="#trimesh.PointCloud.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertices of the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>vertices</strong> – Points in the PointCloud</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.Scene">
<em class="property">class </em><code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">Scene</code><span class="sig-paren">(</span><em class="sig-param">geometry=None</em>, <em class="sig-param">base_frame='world'</em>, <em class="sig-param">metadata={}</em>, <em class="sig-param">graph=None</em>, <em class="sig-param">camera=None</em>, <em class="sig-param">lights=None</em>, <em class="sig-param">camera_transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<p>A simple scene graph which can be rendered directly via
pyglet/openGL or through other endpoints such as a
raytracer. Meshes are added by name, which can then be
moved by updating transform in the transform tree.</p>
<dl class="method">
<dt id="trimesh.Scene.add_geometry">
<code class="sig-name descname">add_geometry</code><span class="sig-paren">(</span><em class="sig-param">geometry</em>, <em class="sig-param">node_name=None</em>, <em class="sig-param">geom_name=None</em>, <em class="sig-param">parent_node_name=None</em>, <em class="sig-param">transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.add_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a geometry to the scene.</p>
<p>If the mesh has multiple transforms defined in its
metadata, they will all be copied into the
TransformForest of the current scene automatically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geometry</strong> (<a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh"><em>Trimesh</em></a><em>, </em><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path2D" title="trimesh.path.path.Path2D"><em>Path2D</em></a><em>, </em><em>Path3D PointCloud</em><em> or </em><em>list</em>) – Geometry to initially add to the scene</p></li>
<li><p><strong>base_frame</strong> (<em>str</em><em> or </em><em>hashable</em>) – Name of base frame</p></li>
<li><p><strong>metadata</strong> (<em>dict</em>) – Any metadata about the scene</p></li>
<li><p><strong>graph</strong> (<a class="reference internal" href="trimesh.scene.html#trimesh.scene.transforms.TransformForest" title="trimesh.scene.transforms.TransformForest"><em>TransformForest</em></a><em> or </em><em>None</em>) – A passed transform graph to use</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>node_name</strong> – Name of node in self.graph</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.apply_transform">
<code class="sig-name descname">apply_transform</code><span class="sig-paren">(</span><em class="sig-param">transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.Scene.bounds">
<em class="property">property </em><code class="sig-name descname">bounds</code><a class="headerlink" href="#trimesh.Scene.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall bounding box of the scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bounds</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(2,3) float points for min, max corner</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.bounds_corners">
<em class="property">property </em><code class="sig-name descname">bounds_corners</code><a class="headerlink" href="#trimesh.Scene.bounds_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of points that represent the corners of the
AABB of every geometry in the scene.</p>
<p>This can be useful if you want to take the AABB in
a specific frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>corners</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n, 3) float, points in space</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.camera">
<em class="property">property </em><code class="sig-name descname">camera</code><a class="headerlink" href="#trimesh.Scene.camera" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the single camera for the scene. If not manually
set one will abe automatically generated.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>camera</strong> – Camera object defined for the scene</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>trimesh.scene.Camera</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.camera_rays">
<code class="sig-name descname">camera_rays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.camera_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the trimesh.scene.Camera origin and ray direction vectors.</p>
<p>Will return one ray per pixel, as set in camera.resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>origins</strong> (<em>(3,) float</em>) – Ray origins in space</p></li>
<li><p><strong>vectors</strong> (<em>(n, 3)</em>) – Ray direction unit vectors in world coordinates</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.camera_transform">
<em class="property">property </em><code class="sig-name descname">camera_transform</code><a class="headerlink" href="#trimesh.Scene.camera_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get camera transform in the base frame</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>camera_transform</strong> – Camera transform in the base frame</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(4, 4), float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.centroid">
<em class="property">property </em><code class="sig-name descname">centroid</code><a class="headerlink" href="#trimesh.Scene.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the center of the bounding box for the scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>centroid</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><ol class="arabic simple" start="3">
<li><p>float point for center of bounding box</p></li>
</ol>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.convert_units">
<code class="sig-name descname">convert_units</code><span class="sig-paren">(</span><em class="sig-param">desired</em>, <em class="sig-param">guess=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.convert_units" title="Permalink to this definition">¶</a></dt>
<dd><p>If geometry has units defined convert them to new units.</p>
<p>Returns a new scene with geometries and transforms scaled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>desired</strong> (<em>str</em>) – Desired final unit system: ‘inches’, ‘mm’, etc.</p></li>
<li><p><strong>guess</strong> (<em>bool</em>) – Is the converter allowed to guess scale when models
don’t have it specified in their metadata.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>scaled</strong> – Copy of scene with scaling applied and units set
for every model</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene">trimesh.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.convex_hull">
<em class="property">property </em><code class="sig-name descname">convex_hull</code><a class="headerlink" href="#trimesh.Scene.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>The convex hull of the whole scene</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>hull</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Trimesh object, convex hull of all meshes in scene</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the current scene</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>copied</strong> – Copy of the current scene</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene">trimesh.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.dump">
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Append all meshes in scene to a list of meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>dumped</strong> – location the scene.graph</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,) list, of Trimesh objects transformed to their</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.duplicate_nodes">
<em class="property">property </em><code class="sig-name descname">duplicate_nodes</code><a class="headerlink" href="#trimesh.Scene.duplicate_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sequence of node keys of identical meshes.</p>
<p>Will combine meshes duplicated by copying in space with different keys in
self.geometry, as well as meshes repeated by self.nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>duplicates</strong> – identical geometry</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><ol class="loweralpha simple" start="13">
<li><p>sequence of keys to self.nodes that represent</p></li>
</ol>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.explode">
<code class="sig-name descname">explode</code><span class="sig-paren">(</span><em class="sig-param">vector=None</em>, <em class="sig-param">origin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.explode" title="Permalink to this definition">¶</a></dt>
<dd><p>Explode a scene around a point and vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vector</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em><em> or </em><em>float</em>) – Explode radially around a direction vector or spherically</p></li>
<li><p><strong>origin</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point to explode around</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.export">
<code class="sig-name descname">export</code><span class="sig-paren">(</span><em class="sig-param">file_obj=None</em>, <em class="sig-param">file_type=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a snapshot of the current scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file_type</strong> (<em>what encoding to use for meshes</em>) – ie: dict, dict64, stl</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>export</strong> – Only returned if file_obj is None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.extents">
<em class="property">property </em><code class="sig-name descname">extents</code><a class="headerlink" href="#trimesh.Scene.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the axis aligned box size of the current scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>extents</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(3,) float, bounding box sides length</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.geometry_identifiers">
<em class="property">property </em><code class="sig-name descname">geometry_identifiers</code><a class="headerlink" href="#trimesh.Scene.geometry_identifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up geometries by identifier MD5</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>identifiers</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict, identifier md5: key in self.geometry</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.is_empty">
<em class="property">property </em><code class="sig-name descname">is_empty</code><a class="headerlink" href="#trimesh.Scene.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the scene have anything in it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>is_empty</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool, True if nothing is in the scene</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.is_valid">
<em class="property">property </em><code class="sig-name descname">is_valid</code><a class="headerlink" href="#trimesh.Scene.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is every geometry connected to the root node.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>is_valid</strong> – Does every geometry have a transform</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.lights">
<em class="property">property </em><code class="sig-name descname">lights</code><a class="headerlink" href="#trimesh.Scene.lights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of the lights in the scene. If nothing is
set it will generate some automatically.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>lights</strong> – Lights in the scene.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<a class="reference internal" href="trimesh.scene.html#trimesh.scene.lighting.Light" title="trimesh.scene.lighting.Light">trimesh.scene.lighting.Light</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.md5">
<code class="sig-name descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>MD5 of scene which will change when meshes or
transforms are changed</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>hashed</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str, MD5 hash of scene</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.rezero">
<code class="sig-name descname">rezero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.rezero" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the current scene so that the AABB of the whole
scene is centered at the origin.</p>
<p>Does this by changing the base frame to a new, offset
base frame.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.save_image">
<code class="sig-name descname">save_image</code><span class="sig-paren">(</span><em class="sig-param">resolution=(1024</em>, <em class="sig-param">768)</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.save_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PNG image of a scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resolution</strong> (<em>(</em><em>2</em><em>,</em><em>) </em><em>int</em><em>, </em><em>resolution to render image</em>) – </p></li>
<li><p><strong>**kwargs</strong> (<em>passed to SceneViewer constructor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>png</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bytes, render of scene in PNG form</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#trimesh.Scene.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate scale of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scale</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float, the mean of the bounding box edge lengths</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.scaled">
<code class="sig-name descname">scaled</code><span class="sig-paren">(</span><em class="sig-param">scale</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the current scene, with meshes and scene
transforms scaled to the requested factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> (<em>float</em>) – Factor to scale meshes and transforms</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>scaled</strong> – A copy of the current scene but scaled</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene">trimesh.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.set_camera">
<code class="sig-name descname">set_camera</code><span class="sig-paren">(</span><em class="sig-param">angles=None</em>, <em class="sig-param">distance=None</em>, <em class="sig-param">center=None</em>, <em class="sig-param">resolution=None</em>, <em class="sig-param">fov=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.set_camera" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a camera object for self.camera, and add
a transform to self.graph for it.</p>
<p>If arguments are not passed sane defaults will be figured
out which show the mesh roughly centered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angles</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Initial euler angles in radians</p></li>
<li><p><strong>distance</strong> (<em>float</em>) – Distance from centroid</p></li>
<li><p><strong>center</strong> (<em>(</em><em>3</em><em>,</em><em>) </em><em>float</em>) – Point camera should be center on</p></li>
<li><p><strong>camera</strong> (<em>Camera object</em>) – Object that stores camera parameters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param">viewer=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.Scene.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the current scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>viewer</strong> (<em>str</em>) – What kind of viewer to open, including
‘gl’ to open a pyglet window, ‘notebook’
for a jupyter notebook or None</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – Includes <cite>smooth</cite>, which will turn
on or off automatic smooth shading</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.triangles">
<em class="property">property </em><code class="sig-name descname">triangles</code><a class="headerlink" href="#trimesh.Scene.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a correctly transformed polygon soup of the
current scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>triangles</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(n,3,3) float, triangles in space</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.triangles_node">
<em class="property">property </em><code class="sig-name descname">triangles_node</code><a class="headerlink" href="#trimesh.Scene.triangles_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Which node of self.graph does each triangle come from.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>triangles_index</strong> – Node name for each triangle</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(len(self.triangles),)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.Scene.units">
<em class="property">property </em><code class="sig-name descname">units</code><a class="headerlink" href="#trimesh.Scene.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the units for every model in the scene, and
raise a ValueError if there are mixed units.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>units</strong> – Units for every model in the scene</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.unitize">
<code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">unitize</code><span class="sig-paren">(</span><em class="sig-param">vectors</em>, <em class="sig-param">check_valid=False</em>, <em class="sig-param">threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.unitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitize a vector or an array or row- vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>(</em><em>n</em><em>,</em><em>m</em><em>) or </em><em>(</em><em>j</em><em>) </em><em>float</em>) – Vector or vectors to be unitized</p></li>
<li><p><strong>check_valid</strong> (<em>bool</em>) – If set, will return mask of nonzero vectors</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Cutoff for a value to be considered zero.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>unit</strong> (<em>(n,m) or (j) float</em>) – Input vectors but unitized</p></li>
<li><p><strong>valid</strong> (<em>(n,) bool or bool</em>) – Mask of nonzero vectors returned if <cite>check_valid</cite></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.load">
<code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">file_obj</em>, <em class="sig-param">file_type=None</em>, <em class="sig-param">resolver=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a mesh or vectorized path into objects like
Trimesh, Path2D, Path3D, Scene</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> (<em>str</em><em>, or </em><em>file- like object</em>) – The source of the data to be loadeded</p></li>
<li><p><strong>file_type</strong> (<em>str</em>) – What kind of file type do we have (eg: ‘stl’)</p></li>
<li><p><strong>resolver</strong> (<em>trimesh.visual.Resolver</em>) – Object to load referenced assets like materials and textures</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – Passed to geometry __init__</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>geometry</strong> – Loaded geometry as trimesh classes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.base.Trimesh" title="trimesh.base.Trimesh">Trimesh</a>, <a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path2D" title="trimesh.path.path.Path2D">Path2D</a>, <a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path3D" title="trimesh.path.path.Path3D">Path3D</a>, <a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene">Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.load_mesh">
<code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">load_mesh</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.load_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a mesh file into a Trimesh object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> (<em>str</em><em> or </em><em>file object</em>) – File name or file with mesh data</p></li>
<li><p><strong>file_type</strong> (<em>str</em><em> or </em><em>None</em>) – Which file type, e.g. ‘stl’</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – Passed to Trimesh constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Loaded geometry data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#trimesh.Trimesh" title="trimesh.Trimesh">trimesh.Trimesh</a> or <a class="reference internal" href="#trimesh.Scene" title="trimesh.Scene">trimesh.Scene</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.load_path">
<code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">load_path</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">file_type=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.load_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a file to a Path object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>One of the following:</em>) – <ul>
<li><p>Path, Path2D, or Path3D objects</p></li>
<li><p>open file object (dxf or svg)</p></li>
<li><p>file name (dxf or svg)</p></li>
<li><p>shapely.geometry.Polygon</p></li>
<li><p>shapely.geometry.MultiLineString</p></li>
<li><p>dict with kwargs for Path constructor</p></li>
<li><p>(n,2,(2|3)) float, line segments</p></li>
</ul>
</p></li>
<li><p><strong>file_type</strong> (<em>str</em>) – Type of file is required if file
object passed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>path</strong> – Data as a native trimesh Path object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path" title="trimesh.path.path.Path">Path</a>, <a class="reference internal" href="trimesh.path.html#trimesh.path.path.Path2D" title="trimesh.path.path.Path2D">Path2D</a>, Path3D object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.load_remote">
<code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">load_remote</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.load_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a mesh at a remote URL into a local trimesh object.</p>
<p>This must be called explicitly rather than automatically
from trimesh.load to ensure users don’t accidentally make
network requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> (<em>string</em>) – URL containing mesh file</p></li>
<li><p><strong>**kwargs</strong> (passed to <cite>load</cite>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.transform_points">
<code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">transform_points</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">matrix</em>, <em class="sig-param">translate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.transform_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns points, rotated by transformation matrix</p>
<p>If points is (n,2), matrix must be (3,3)
if points is (n,3), matrix must be (4,4)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>(</em><em>n</em><em>, </em><em>d</em><em>) </em><em>float</em>) – Points where d is 2 or 3</p></li>
<li><p><strong>matrix</strong> (<em>(</em><em>3</em><em>,</em><em>3</em><em>) or </em><em>(</em><em>4</em><em>,</em><em>4</em><em>) </em><em>float</em>) – Homogeneous rotation matrix</p></li>
<li><p><strong>translate</strong> (<em>bool</em>) – Apply translation from matrix or not</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>transformed</strong> – Transformed points</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(n,d) float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.available_formats">
<code class="sig-prename descclassname">trimesh.</code><code class="sig-name descname">available_formats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.available_formats" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of all available loaders</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>loaders</strong> – Extensions of available loaders
i.e. ‘stl’, ‘ply’, ‘dxf’, etc.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="trimesh.exchange.html" class="btn btn-neutral float-right" title="trimesh.exchange package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modules.html" class="btn btn-neutral float-left" title="Module Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Michael Dawson-Haggerty

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>